# Codebase Export: /src folder
Generated on: Tue Dec 23 14:28:43 CET 2025
------------------------------------------------
## Project Structure (/src)
```
src
 |-- App.tsx
 |-- main.tsx
 |-- App.css
 |-- index.css
 |-- types.ts
 |-- components
 | |-- editor
 | | |-- Palette.tsx
 | | |-- Toolbar.tsx
 | | |-- LayerPanel.tsx
 | | |-- MapCanvas.tsx
 | | |-- RecentTiles.tsx
 |-- constants.ts
 |-- hooks
 | |-- useMapState.ts
 |-- assets
 | |-- PathAndObjects.png
 | |-- project.png
 | |-- TileSet.png
 |-- editor
 | |-- MapEditor.tsx
```

## Project Files
---
### File: src/App.tsx
```tsx
import "./App.css";
import { MapEditor } from "./editor/MapEditor";

function App() {
	return <MapEditor />;
}

export default App;

```

---
### File: src/main.tsx
```tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

```

---
### File: src/App.css
```css
@import "tailwindcss";

```

---
### File: src/index.css
```css

```

---
### File: src/types.ts
```ts
export type TileData = { tileId: number; flipX: boolean };
export type Layer = { id: string; name: string; visible: boolean; opacity: number; data: Record<string, TileData> };
export type Tool = "brush" | "eraser" | "fill" | "marquee";
export type SelectionRect = { x: number; y: number; w: number; h: number };

```

---
### File: src/components/editor/Palette.tsx
```tsx
import React, { useRef, useEffect, type MouseEvent } from "react";
import { type SelectionRect } from "../../types";
import { TILE_WIDTH, TILE_HEIGHT } from "../../constants";

type PaletteProps = {
    image: HTMLImageElement | null;
    selection: SelectionRect;
    setSelection: React.Dispatch<React.SetStateAction<SelectionRect>>;
    zoom: number;
    setZoom: React.Dispatch<React.SetStateAction<number>>;
    isFlipped: boolean;
    onToolChange: () => void;
};

export function Palette({ image, selection, setSelection, zoom, setZoom, isFlipped, onToolChange }: PaletteProps) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const isMouseDown = useRef(false);
    const selectionStart = useRef<{ x: number; y: number } | null>(null);

    function renderPalette() {
        const canvas = canvasRef.current;
        const context = canvas?.getContext("2d");
        if (!canvas || !context || !image) return;

        // Resize canvas logic:
        const logicalWidth = image.width;
        const logicalHeight = image.height;

        if (canvas.width !== logicalWidth || canvas.height !== logicalHeight) {
            canvas.width = logicalWidth;
            canvas.height = logicalHeight;
        }

        context.imageSmoothingEnabled = false;
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Source Image
        context.drawImage(image, 0, 0);

        // Draw Grid Overlay on Palette
        context.beginPath();
        // Vertical lines
        for (let i = 0; i <= image.width; i += TILE_WIDTH) {
            context.moveTo(i, 0);
            context.lineTo(i, image.height);
        }
        // Horizontal lines
        for (let i = 0; i <= image.height; i += TILE_HEIGHT) {
            context.moveTo(0, i);
            context.lineTo(image.width, i);
        }
        context.strokeStyle = "rgba(0,0,0, 0.2)";
        context.lineWidth = 1;
        context.stroke();

        // Draw Selection Box on Palette
        const drawX = selection.x * TILE_WIDTH;
        const drawY = selection.y * TILE_HEIGHT;
        const drawW = selection.w * TILE_WIDTH;
        const drawH = selection.h * TILE_HEIGHT;

        context.beginPath();
        context.strokeStyle = "white";
        context.lineWidth = 2;
        context.setLineDash([4, 4]);
        context.strokeRect(drawX, drawY, drawW, drawH);

        context.strokeStyle = "black";
        context.lineDashOffset = 4;
        context.strokeRect(drawX, drawY, drawW, drawH);

        context.setLineDash([]);
        context.lineDashOffset = 0;
    }

    useEffect(() => {
        renderPalette();
    }, [image, selection, zoom]);

    function handleMouseDown(e: MouseEvent<HTMLCanvasElement>) {
        const canvas = canvasRef.current;
        if (!canvas) return;

        isMouseDown.current = true;
        const x = e.nativeEvent.offsetX / zoom;
        const y = e.nativeEvent.offsetY / zoom;

        const tileX = Math.floor(x / TILE_WIDTH);
        const tileY = Math.floor(y / TILE_HEIGHT);

        selectionStart.current = { x: tileX, y: tileY };
        setSelection({ x: tileX, y: tileY, w: 1, h: 1 });

        onToolChange();
    }

    function handleMouseMove(e: MouseEvent<HTMLCanvasElement>) {
        if (!isMouseDown.current || !selectionStart.current) return;

        const canvas = canvasRef.current;
        if (!canvas || !image) return;

        const x = e.nativeEvent.offsetX / zoom;
        const y = e.nativeEvent.offsetY / zoom;

        // Constrain to image bounds
        const tileX = Math.max(0, Math.min(Math.floor(x / TILE_WIDTH), Math.floor(image.width / TILE_WIDTH) - 1));
        const tileY = Math.max(0, Math.min(Math.floor(y / TILE_HEIGHT), Math.floor(image.height / TILE_HEIGHT) - 1));

        const start = selectionStart.current;
        const minX = Math.min(start.x, tileX);
        const minY = Math.min(start.y, tileY);
        const w = Math.abs(start.x - tileX) + 1;
        const h = Math.abs(start.y - tileY) + 1;

        setSelection({ x: minX, y: minY, w, h });
    }

    function handleMouseUp() {
        isMouseDown.current = false;
    }

    function handleWheel(e: React.WheelEvent) {
        if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            setZoom((z) => {
                const newZoom = z - e.deltaY * 0.001;
                // Clamp between 0.25x and 4x
                return Math.max(0.25, Math.min(4, newZoom));
            });
        }
    }

    return (
        <div className="flex-none flex flex-col h-full" style={{ width: "100%" }}>
            <h3 className="font-bold mb-2">Palette</h3>
            <div className="border border-gray-400 bg-gray-50 flex-1 overflow-auto">
                <canvas
                    ref={canvasRef}
                    className="cursor-pointer block origin-top-left"
                    style={{
                        width: image ? image.width * zoom : undefined,
                        height: image ? image.height * zoom : undefined,
                        imageRendering: "pixelated",
                    }}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onWheel={handleWheel}
                    aria-label="Palette Grid - Use arrow keys to navigate"
                    tabIndex={0}
                />
            </div>
            <div className="mt-2 text-sm text-gray-500">
                Drag to select multiple tiles.
                <br />
                Shortcuts: B (Brush), E (Eraser), F (Fill), X (Flip)
            </div>
            <div
                className={`mt-2 p-1 text-xs text-center border rounded ${isFlipped ? "bg-blue-100 border-blue-500 font-bold" : "bg-gray-100 text-gray-400"}`}
            >
                Flip X: {isFlipped ? "ON" : "OFF"}
            </div>
        </div>
    );
}

```

---
### File: src/components/editor/Toolbar.tsx
```tsx
import React from "react";
import { type Tool } from "../../types";

type ToolbarProps = {
    mapSize: { width: number; height: number };
    setMapSize: React.Dispatch<React.SetStateAction<{ width: number; height: number }>>;
    currentTool: Tool;
    setCurrentTool: React.Dispatch<React.SetStateAction<Tool>>;
    onSave: () => void;
    onLoad: (e: React.ChangeEvent<HTMLInputElement>) => void;
    onExport: () => void;
    onUploadImage: (e: React.ChangeEvent<HTMLInputElement>) => void;
};

export function Toolbar({
    mapSize,
    setMapSize,
    currentTool,
    setCurrentTool,
    onSave,
    onLoad,
    onExport,
    onUploadImage,
}: ToolbarProps) {
    return (
        <div className="flex flex-wrap gap-4 items-center mb-4 flex-none">
            <div className="flex gap-2 items-center bg-gray-100 p-2 rounded">
                <label className="text-sm">
                    W:
                    <input
                        type="number"
                        className="ml-1 w-16 p-1 rounded border"
                        value={mapSize.width}
                        onChange={(e) => setMapSize((prev) => ({ ...prev, width: Number(e.target.value) }))}
                    />
                </label>
                <label className="text-sm">
                    H:
                    <input
                        type="number"
                        className="ml-1 w-16 p-1 rounded border"
                        value={mapSize.height}
                        onChange={(e) => setMapSize((prev) => ({ ...prev, height: Number(e.target.value) }))}
                    />
                </label>
            </div>
            <input type="file" accept="image/png" className="block" onChange={onUploadImage} />

            <div className="flex gap-1 bg-gray-100 p-1 rounded">
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "brush" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("brush")}
                    title="Shortcut: B"
                >
                    Brush
                </button>
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "eraser" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("eraser")}
                    title="Shortcut: E"
                >
                    Eraser
                </button>
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "fill" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("fill")}
                    title="Shortcut: F or G"
                >
                    Fill
                </button>
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "marquee" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("marquee")}
                >
                    Marquee
                </button>
            </div>

            <div className="flex gap-2 p-2 bg-gray-100 rounded border border-gray-300">
                <button
                    className="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700"
                    onClick={onSave}
                >
                    Save JSON
                </button>
                <label className="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700 cursor-pointer">
                    Load JSON
                    <input type="file" accept=".json" className="hidden" onChange={onLoad} />
                </label>
                <button
                    className="px-3 py-1 bg-purple-600 text-white rounded text-sm hover:bg-purple-700"
                    onClick={onExport}
                >
                    Export PNG
                </button>
            </div>
        </div>
    );
}

```

---
### File: src/components/editor/LayerPanel.tsx
```tsx
import { type Layer } from "../../types";

type LayerPanelProps = {
    layers: Layer[];
    activeLayerIndex: number;
    setActiveLayerIndex: (index: number) => void;
    onToggleVisibility: (index: number) => void;
};

export function LayerPanel({ layers, activeLayerIndex, setActiveLayerIndex, onToggleVisibility }: LayerPanelProps) {
    return (
        <div className="h-40 border-t border-gray-300 bg-gray-50 p-2 flex flex-col">
            <h4 className="text-sm font-bold mb-2">Layers</h4>
            <div className="flex-1 overflow-auto space-y-1">
                {layers.map((layer, index) => (
                    <div
                        key={layer.id}
                        className={`flex items-center p-1 rounded cursor-pointer ${activeLayerIndex === index ? "bg-blue-100 ring-1 ring-blue-500" : "hover:bg-gray-100"}`}
                        onClick={() => setActiveLayerIndex(index)}
                    >
                        <button
                            className="mr-2 text-gray-500 hover:text-black"
                            onClick={(e) => {
                                e.stopPropagation();
                                onToggleVisibility(index);
                            }}
                        >
                            {layer.visible ? "üëÅÔ∏è" : "üö´"}
                        </button>
                        <span className={`text-sm select-none ${!layer.visible && "text-gray-400"}`}>{layer.name}</span>
                    </div>
                ))}
            </div>
        </div>
    );
}

```

---
### File: src/components/editor/MapCanvas.tsx
```tsx
import { useRef, useEffect, type MouseEvent } from "react";
import { type Layer, type SelectionRect, type Tool } from "../../types";
import { TILE_WIDTH, TILE_HEIGHT } from "../../constants";

type MapCanvasProps = {
    layers: Layer[];
    mapSize: { width: number; height: number };
    zoom: number;
    setZoom: React.Dispatch<React.SetStateAction<number>>;
    selection: SelectionRect | null;
    image: HTMLImageElement | null;
    currentTool: Tool;
    paletteSelection: SelectionRect;
    isFlipped: boolean;
    onMouseDown: (e: MouseEvent<HTMLCanvasElement>) => void;
    onMouseMove: (e: MouseEvent<HTMLCanvasElement>) => void;
    onMouseUp: () => void;
    onMouseLeave: () => void;
};

export function MapCanvas({
    layers,
    mapSize,
    zoom,
    setZoom,
    selection,
    image,
    currentTool,
    paletteSelection,
    isFlipped,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    onMouseLeave,
}: MapCanvasProps) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const mousePosRef = useRef<{ x: number; y: number } | null>(null);
    const reqIdRef = useRef<number | null>(null);

    function renderMap() {
        const canvas = canvasRef.current;
        const context = canvas?.getContext("2d");
        if (!canvas || !context || !image) return;

        // Resize map canvas
        const logicalWidth = mapSize.width * TILE_WIDTH;
        const logicalHeight = mapSize.height * TILE_HEIGHT;

        if (canvas.width !== logicalWidth || canvas.height !== logicalHeight) {
            canvas.width = logicalWidth;
            canvas.height = logicalHeight;
        }

        context.imageSmoothingEnabled = false;
        context.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Map Tiles (Layered)
        layers.forEach((layer) => {
            if (!layer.visible) return;

            context.save();
            context.globalAlpha = layer.opacity;

            Object.entries(layer.data).forEach(([key, tileData]) => {
                const [gx, gy] = key.split(",").map(Number);
                const drawX = gx * TILE_WIDTH;
                const drawY = gy * TILE_HEIGHT;

                const tilesPerRow = Math.floor(image.width / TILE_WIDTH);
                const srcX = (tileData.tileId % tilesPerRow) * TILE_WIDTH;
                const srcY = Math.floor(tileData.tileId / tilesPerRow) * TILE_HEIGHT;

                context.save();
                if (tileData.flipX) {
                    context.translate(drawX + TILE_WIDTH, drawY);
                    context.scale(-1, 1);
                    context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, 0, 0, TILE_WIDTH, TILE_HEIGHT);
                } else {
                    context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, drawX, drawY, TILE_WIDTH, TILE_HEIGHT);
                }
                context.restore();
            });

            context.restore();
        });

        // 2. Draw Grid
        context.beginPath();
        for (let i = 0; i <= mapSize.width; i++) {
            context.moveTo(i * TILE_WIDTH, 0);
            context.lineTo(i * TILE_WIDTH, logicalHeight);
        }
        for (let i = 0; i <= mapSize.height; i++) {
            context.moveTo(0, i * TILE_HEIGHT);
            context.lineTo(logicalWidth, i * TILE_HEIGHT);
        }
        context.strokeStyle = "rgba(0,0,0, 0.4)";
        context.lineWidth = 1;
        context.stroke();

        // 3. Draw Selection Marquee
        if (selection) {
            const selX = selection.x * TILE_WIDTH;
            const selY = selection.y * TILE_HEIGHT;
            const selW = selection.w * TILE_WIDTH;
            const selH = selection.h * TILE_HEIGHT;

            // Fill
            context.fillStyle = "rgba(0, 140, 255, 0.2)";
            context.fillRect(selX, selY, selW, selH);

            // Border
            context.beginPath();
            context.strokeStyle = "white";
            context.lineWidth = 2;
            context.setLineDash([4, 4]);
            context.strokeRect(selX, selY, selW, selH);

            context.strokeStyle = "black";
            context.setLineDash([4, 4]);
            context.lineDashOffset = 4;
            context.strokeRect(selX, selY, selW, selH);

            context.setLineDash([]);
            context.lineDashOffset = 0;
        }

        // 4. Draw Ghost/Hover Cursor
        if (mousePosRef.current) {
            const gridX = Math.floor(mousePosRef.current.x / TILE_WIDTH) * TILE_WIDTH;
            const gridY = Math.floor(mousePosRef.current.y / TILE_HEIGHT) * TILE_HEIGHT;

            // Draw Ghost Tile
            if (currentTool === "brush" || currentTool === "fill") {
                context.globalAlpha = 0.5;

                const previewW = currentTool === "brush" ? paletteSelection.w : 1;
                const previewH = currentTool === "brush" ? paletteSelection.h : 1;

                for (let dy = 0; dy < previewH; dy++) {
                    for (let dx = 0; dx < previewW; dx++) {
                        const srcDx = isFlipped ? (previewW - 1 - dx) : dx;
                        const srcX = (paletteSelection.x + srcDx) * TILE_WIDTH;
                        const srcY = (paletteSelection.y + dy) * TILE_HEIGHT;
                        const destX = gridX + (dx * TILE_WIDTH);
                        const destY = gridY + (dy * TILE_HEIGHT);

                        context.save();
                        if (isFlipped) {
                            context.translate(destX + TILE_WIDTH, destY);
                            context.scale(-1, 1);
                            context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, 0, 0, TILE_WIDTH, TILE_HEIGHT);
                        } else {
                            context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, destX, destY, TILE_WIDTH, TILE_HEIGHT);
                        }
                        context.restore();
                    }
                }
                context.globalAlpha = 1.0;
            }

            // Draw Cursor Border
            if (currentTool === "brush") {
                const drawW = paletteSelection.w * TILE_WIDTH;
                const drawH = paletteSelection.h * TILE_HEIGHT;

                context.beginPath();
                context.strokeStyle = "white";
                context.lineWidth = 1;
                context.setLineDash([4, 4]);
                context.strokeRect(gridX, gridY, drawW, drawH);

                context.strokeStyle = "black";
                context.lineDashOffset = 4;
                context.strokeRect(gridX, gridY, drawW, drawH);
                context.setLineDash([]);
                context.lineDashOffset = 0;
            } else {
                // Single tile hover (Eraser, Fill, etc)
                context.beginPath();
                context.strokeStyle = "white";
                context.lineWidth = 1;
                context.setLineDash([4, 4]);
                context.strokeRect(gridX, gridY, TILE_WIDTH, TILE_HEIGHT);

                context.strokeStyle = "black";
                context.lineDashOffset = 4;
                context.strokeRect(gridX, gridY, TILE_WIDTH, TILE_HEIGHT);
                context.setLineDash([]);
                context.lineDashOffset = 0;
            }
        }
    }

    useEffect(() => {
        function loop() {
            renderMap();
            reqIdRef.current = requestAnimationFrame(loop);
        }
        loop();
        return () => {
            if (reqIdRef.current) cancelAnimationFrame(reqIdRef.current);
        };
    }, [layers, selection, mapSize, zoom, image, paletteSelection, currentTool, isFlipped]);

    function handleInternalMouseMove(e: MouseEvent<HTMLCanvasElement>) {
        // Calculate hover pos
        const x = e.nativeEvent.offsetX / zoom;
        const y = e.nativeEvent.offsetY / zoom;
        mousePosRef.current = { x, y };

        // Propagate
        onMouseMove(e);
    }

    function handleInternalMouseLeave() {
        mousePosRef.current = null;
        onMouseLeave();
    }

    function handleWheel(e: React.WheelEvent) {
        if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            setZoom((z) => {
                const newZoom = z - e.deltaY * 0.001;
                return Math.max(0.25, Math.min(4, newZoom));
            });
        }
    }

    return (
        <div className="border-2 border-gray-300 bg-gray-100 flex-1 overflow-auto relative rounded">
            <canvas
                ref={canvasRef}
                className="block bg-white shadow-sm origin-top-left"
                style={{
                    width: mapSize.width * TILE_WIDTH * zoom,
                    height: mapSize.height * TILE_HEIGHT * zoom,
                    imageRendering: "pixelated",
                }}
                onMouseDown={onMouseDown}
                onMouseMove={handleInternalMouseMove}
                onMouseUp={onMouseUp}
                onMouseLeave={handleInternalMouseLeave}
                onWheel={handleWheel}
                aria-label="Map Grid"
                tabIndex={0}
            ></canvas>
        </div>
    );
}

```

---
### File: src/components/editor/RecentTiles.tsx
```tsx
import { useRef, useEffect } from "react";
import { type SelectionRect } from "../../types";
import { TILE_WIDTH, TILE_HEIGHT } from "../../constants";

type RecentTilesProps = {
    recentStamps: SelectionRect[];
    onSelect: (stamp: SelectionRect) => void;
    image: HTMLImageElement | null;
    activeStamp: SelectionRect;
};

export function RecentTiles({ recentStamps, onSelect, image, activeStamp }: RecentTilesProps) {
    return (
        <div className="flex gap-2 p-2 bg-gray-50 border-b overflow-x-auto h-12 items-center">
            <span className="text-xs font-bold text-gray-500 mr-2 flex-none">History:</span>
            {recentStamps.map((stamp, i) => (
                <TilePreview
                    key={i}
                    stamp={stamp}
                    image={image}
                    onClick={() => onSelect(stamp)}
                    isActive={
                        activeStamp.x === stamp.x &&
                        activeStamp.y === stamp.y &&
                        activeStamp.w === stamp.w &&
                        activeStamp.h === stamp.h
                    }
                />
            ))}
            {recentStamps.length === 0 && (
                <span className="text-xs text-gray-400 italic">Select stamps to see history...</span>
            )}
        </div>
    );
}

function TilePreview({
    stamp,
    image,
    onClick,
    isActive,
}: {
    stamp: SelectionRect;
    image: HTMLImageElement | null;
    onClick: () => void;
    isActive: boolean;
}) {
    const canvasRef = useRef<HTMLCanvasElement>(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas?.getContext("2d");
        if (!canvas || !ctx || !image) return;

        // Scale down if large
        const stampW = stamp.w * TILE_WIDTH;
        const stampH = stamp.h * TILE_HEIGHT;

        // Fit to 32x32 max
        const scale = Math.min(32 / stampW, 32 / stampH);

        ctx.clearRect(0, 0, 32, 32);
        ctx.imageSmoothingEnabled = false;

        const drawW = stampW * scale;
        const drawH = stampH * scale;

        // Center
        const offsetX = (32 - drawW) / 2;
        const offsetY = (32 - drawH) / 2;

        ctx.drawImage(
            image,
            stamp.x * TILE_WIDTH,
            stamp.y * TILE_HEIGHT,
            stampW,
            stampH,
            offsetX,
            offsetY,
            drawW,
            drawH
        );

    }, [stamp, image]);

    return (
        <div
            onClick={onClick}
            className={`w-8 h-8 border rounded flex-none cursor-pointer hover:border-blue-400 bg-white ${isActive ? "border-blue-600 ring-1 ring-blue-600" : "border-gray-300"
                }`}
            title={`Stamp ${stamp.x},${stamp.y} (${stamp.w}x${stamp.h})`}
        >
            <canvas ref={canvasRef} width={32} height={32} className="w-full h-full" />
        </div>
    );
}

```

---
### File: src/constants.ts
```ts
export const TILE_WIDTH = 32;
export const TILE_HEIGHT = 32;

```

---
### File: src/hooks/useMapState.ts
```ts
import { useState, useEffect, useRef, useCallback } from "react";
import { useImmer } from "use-immer";
import { type Layer } from "../types";

const STORAGE_KEY = "tile_craft_editor_v1";

// 4.5 MB Limit (Safe margin for 5MB localStorage)
const STORAGE_SIZE_LIMIT = 4.5 * 1024 * 1024;

const INITIAL_LAYERS: Layer[] = [
    { id: "ground", name: "Ground", visible: true, opacity: 1, data: {} },
    { id: "decor", name: "Decoration", visible: true, opacity: 1, data: {} },
    { id: "collision", name: "Collision", visible: true, opacity: 0.5, data: {} },
];

const INITIAL_MAP_SIZE = { width: 64, height: 16 };

export function useMapState() {
    const [layers, setLayers] = useImmer<Layer[]>(INITIAL_LAYERS);
    const [mapSize, setMapSize] = useState(INITIAL_MAP_SIZE);

    // History Stacks
    const historyPast = useRef<Layer[][]>([]);
    const historyFuture = useRef<Layer[][]>([]);

    const isHydrated = useRef(false);
    const saveTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

    // Hydration
    useEffect(() => {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (raw) {
                const data = JSON.parse(raw);
                if (data && Array.isArray(data.layers) && data.mapSize) {
                    setLayers(data.layers);
                    setMapSize(data.mapSize);
                } else if (Array.isArray(data)) {
                    // Legacy fallback if just layers were saved
                    setLayers(data);
                }
            }
        } catch (e) {
            console.error("Failed to hydrate map state", e);
        } finally {
            isHydrated.current = true;
        }
    }, [setLayers]);

    // Persistence
    useEffect(() => {
        if (!isHydrated.current) return;

        if (saveTimeoutRef.current) {
            clearTimeout(saveTimeoutRef.current);
        }

        saveTimeoutRef.current = setTimeout(() => {
            try {
                const state = {
                    layers,
                    mapSize
                };
                const json = JSON.stringify(state);

                if (json.length > STORAGE_SIZE_LIMIT) {
                    console.warn(`Map data exceeds storage limit (${(json.length / 1024 / 1024).toFixed(2)}MB)`);
                    return;
                }

                localStorage.setItem(STORAGE_KEY, json);
            } catch (e) {
                console.error("Failed to save map state", e);
            }
        }, 500); // 500ms debounce

        return () => {
            if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
        };
    }, [layers, mapSize]);

    // Checkpoint
    const saveCheckpoint = useCallback(() => {
        historyPast.current.push(layers);
        if (historyPast.current.length > 50) historyPast.current.shift();
        historyFuture.current = [];
    }, [layers]);

    // Undo
    const performUndo = useCallback(() => {
        if (historyPast.current.length === 0) return;
        const previous = historyPast.current.pop();
        if (previous) {
            historyFuture.current.push(layers);
            setLayers(previous);
        }
    }, [layers, setLayers]);

    // Redo
    const performRedo = useCallback(() => {
        if (historyFuture.current.length === 0) return;
        const next = historyFuture.current.pop();
        if (next) {
            historyPast.current.push(layers);
            setLayers(next);
        }
    }, [layers, setLayers]);

    // Clear history on map size change to avoid incongruity? 
    // Or just let it be. Usually resizing doesn't break tile data directly but 
    // for simplicity we won't clear history.

    return {
        layers,
        setLayers,
        mapSize,
        setMapSize,
        saveCheckpoint,
        performUndo,
        performRedo,
    };
}

```

---
### File: src/editor/MapEditor.tsx
```tsx
import { useRef, useState, useEffect, type MouseEvent } from "react";
import { useImmer } from "use-immer";
import spritesheet from "../assets/project.png";
import { useMapState } from "../hooks/useMapState";
import { type TileData, type Tool, type SelectionRect } from "../types";
import { TILE_WIDTH, TILE_HEIGHT } from "../constants";
import { LayerPanel } from "../components/editor/LayerPanel";
import { Toolbar } from "../components/editor/Toolbar";
import { Palette } from "../components/editor/Palette";
import { RecentTiles } from "../components/editor/RecentTiles";
import { MapCanvas } from "../components/editor/MapCanvas";

export function MapEditor() {
    const {
        layers,
        setLayers,
        mapSize,
        setMapSize,
        saveCheckpoint,
        performUndo,
        performRedo
    } = useMapState();

    const [image, setImage] = useState<HTMLImageElement | null>(null);
    const [paletteWidth, setPaletteWidth] = useState(280);
    const [zoomMap, setZoomMap] = useState(1);
    const [zoomPalette, setZoomPalette] = useState(1);
    const [isFlipped, setIsFlipped] = useState(false);
    const [paletteSelection, setPaletteSelection] = useState<SelectionRect>({ x: 0, y: 0, w: 1, h: 1 });
    const [activeLayerIndex, setActiveLayerIndex] = useState(0);
    const [currentTool, setCurrentTool] = useState<Tool>("brush");
    const [selection, setSelection] = useState<SelectionRect | null>(null);
    const [clipboard, setClipboard] = useState<Record<string, TileData> | null>(null);
    const [recentStamps, setRecentStamps] = useImmer<SelectionRect[]>([]);

    const isMouseDown = useRef(false);
    const isResizing = useRef(false);
    const lastPaintedTiles = useRef<Set<string>>(new Set());
    const selectionStart = useRef<{ x: number; y: number } | null>(null);


    function addRecentStamp(stamp: SelectionRect) {
        setRecentStamps(draft => {
            // Remove exact duplicate
            const index = draft.findIndex(s =>
                s.x === stamp.x && s.y === stamp.y && s.w === stamp.w && s.h === stamp.h
            );
            if (index !== -1) {
                draft.splice(index, 1);
            }
            // Add to front
            draft.unshift(stamp);
            // Limit to 10
            if (draft.length > 10) {
                draft.pop();
            }
        });
    }

    // Load Image and Init
    useEffect(() => {
        if (!spritesheet) return;
        const img = new Image();
        img.src = spritesheet;
        img.onload = () => {

            setImage(img);
        };
    }, []);

    useEffect(() => {
        function handleKeyDown(e: KeyboardEvent) {
            if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;

            if (e.key.toLowerCase() === "b") setCurrentTool("brush");
            if (e.key.toLowerCase() === "e") setCurrentTool("eraser");
            if (e.key.toLowerCase() === "g" || e.key.toLowerCase() === "f") setCurrentTool("fill");
            if (e.key.toLowerCase() === "x") setIsFlipped(prev => !prev);

            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                e.preventDefault();
                setPaletteSelection(prev => {

                    if (!image) return prev;
                    let { x, y } = prev;
                    const maxW = Math.floor(image.width / TILE_WIDTH) - 1;
                    const maxH = Math.floor(image.height / TILE_HEIGHT) - 1;
                    if (e.key === "ArrowLeft") x = Math.max(0, x - 1);
                    if (e.key === "ArrowRight") x = Math.min(maxW, x + 1);
                    if (e.key === "ArrowUp") y = Math.max(0, y - 1);
                    if (e.key === "ArrowDown") y = Math.min(maxH, y + 1);

                    // Add to recent
                    const newSel = { ...prev, x, y };
                    addRecentStamp(newSel);

                    return newSel;
                });
                setCurrentTool("brush");
            }

            if (e.key === "Delete" || e.key === "Backspace") {
                if (selection) {
                    saveCheckpoint();
                    setLayers((draft) => {
                        const activeData = draft[activeLayerIndex].data;
                        for (let x = selection.x; x < selection.x + selection.w; x++) {
                            for (let y = selection.y; y < selection.y + selection.h; y++) {
                                delete activeData[`${x},${y}`];
                            }
                        }
                    });
                }
            }

            if ((e.metaKey || e.ctrlKey) && e.key === "z") {
                e.preventDefault();
                if (e.shiftKey) {
                    performRedo();
                } else {
                    performUndo();
                }
            }

            if ((e.metaKey || e.ctrlKey) && e.key === "c") {
                if (selection) {
                    const newClipboard: Record<string, TileData> = {};
                    const activeData = layers[activeLayerIndex].data;
                    for (let x = selection.x; x < selection.x + selection.w; x++) {
                        for (let y = selection.y; y < selection.y + selection.h; y++) {
                            const key = `${x},${y}`;
                            if (activeData[key]) {
                                newClipboard[`${x - selection.x},${y - selection.y}`] = activeData[key];
                            }
                        }
                    }
                    setClipboard(newClipboard);
                    console.log("Copied", Object.keys(newClipboard).length, "tiles");
                }
            }

            if ((e.metaKey || e.ctrlKey) && e.key === "v") {
                if (clipboard) {
                    saveCheckpoint();
                    const targetX = selection ? selection.x : 0;
                    const targetY = selection ? selection.y : 0;

                    setLayers((draft) => {
                        const activeData = draft[activeLayerIndex].data;
                        let maxClipboardX = 0;
                        if (isFlipped) {
                            Object.keys(clipboard).forEach(key => {
                                const [gx] = key.split(",").map(Number);
                                if (gx > maxClipboardX) maxClipboardX = gx;
                            });
                        }
                        Object.entries(clipboard).forEach(([key, tileData]) => {
                            const [gx, gy] = key.split(",").map(Number);
                            let finalGx = gx;
                            let finalTileData = { ...tileData };
                            if (isFlipped) {
                                finalGx = maxClipboardX - gx;
                                finalTileData.flipX = !finalTileData.flipX;
                            }
                            const finalX = targetX + finalGx;
                            const finalY = targetY + gy;
                            activeData[`${finalX},${finalY}`] = finalTileData;
                        });
                    });
                }
            }
        }

        window.addEventListener("keydown", handleKeyDown);
        return () => window.removeEventListener("keydown", handleKeyDown);
    }, [layers, selection, clipboard, activeLayerIndex, isFlipped, image]);

    // Resize Logic
    useEffect(() => {
        function handleMouseMove(e: globalThis.MouseEvent) {
            if (isResizing.current) {
                let newWidth = e.clientX;
                if (newWidth < 150) newWidth = 150;
                if (newWidth > 800) newWidth = 800;
                setPaletteWidth(newWidth);
            }
        }

        function handleMouseUp() {
            isResizing.current = false;
            document.body.style.cursor = "default";
        }

        window.addEventListener("mousemove", handleMouseMove);
        window.addEventListener("mouseup", handleMouseUp);
        return () => {
            window.removeEventListener("mousemove", handleMouseMove);
            window.removeEventListener("mouseup", handleMouseUp);
        };
    }, []);

    function paintTile(gridX: number, gridY: number, tileId: number | null) {
        const gx = Math.floor(gridX / TILE_WIDTH);
        const gy = Math.floor(gridY / TILE_HEIGHT);
        const key = `${gx},${gy}`;

        setLayers((draft) => {
            const activeData = draft[activeLayerIndex].data;
            if (tileId === null) {
                delete activeData[key];
            } else {
                activeData[key] = { tileId, flipX: isFlipped };
            }
        });
    }

    function floodFill(startGridX: number, startGridY: number, fillTileId: number) {
        const startKey = `${startGridX},${startGridY}`;
        setLayers((draft) => {
            const activeData = draft[activeLayerIndex].data;
            const startTileId = activeData[startKey]?.tileId;

            if (startTileId === fillTileId) return;

            const visited = new Set<string>();
            const queue = [[startGridX, startGridY]];

            const getId = (x: number, y: number) => activeData[`${x},${y}`]?.tileId;

            while (queue.length > 0) {
                const [cx, cy] = queue.pop()!;
                const key = `${cx},${cy}`;

                if (visited.has(key)) continue;
                if (cx < 0 || cx >= mapSize.width || cy < 0 || cy >= mapSize.height) continue;

                const currentId = getId(cx, cy);
                if (currentId !== startTileId) continue;

                visited.add(key);
                activeData[key] = { tileId: fillTileId, flipX: isFlipped };

                queue.push([cx + 1, cy]);
                queue.push([cx - 1, cy]);
                queue.push([cx, cy + 1]);
                queue.push([cx, cy - 1]);
            }
        });
    }

    function handleMapInteraction(e: MouseEvent<HTMLCanvasElement>) {
        // e.nativeEvent.offsetX is relative to the canvas
        const x = e.nativeEvent.offsetX / zoomMap;
        const y = e.nativeEvent.offsetY / zoomMap;

        const pixelWidth = mapSize.width * TILE_WIDTH;
        const pixelHeight = mapSize.height * TILE_HEIGHT;

        if (x < 0 || y < 0 || x >= pixelWidth || y >= pixelHeight) return;

        const gridX = Math.floor(x / TILE_WIDTH) * TILE_WIDTH;
        const gridY = Math.floor(y / TILE_HEIGHT) * TILE_HEIGHT;
        const gx = Math.floor(x / TILE_WIDTH);
        const gy = Math.floor(y / TILE_HEIGHT);
        const tileKey = `${gx},${gy}`;

        if (lastPaintedTiles.current.has(tileKey)) return;


        if (!image) return;
        const tilesPerRow = Math.floor(image.width / TILE_WIDTH);

        if (currentTool === "brush") {
            for (let dy = 0; dy < paletteSelection.h; dy++) {
                for (let dx = 0; dx < paletteSelection.w; dx++) {
                    const srcDx = isFlipped ? (paletteSelection.w - 1 - dx) : dx;
                    const px = paletteSelection.x + srcDx;
                    const py = paletteSelection.y + dy;
                    const tileId = py * tilesPerRow + px;

                    const targetX = gridX + (dx * TILE_WIDTH);
                    const targetY = gridY + (dy * TILE_HEIGHT);

                    if (targetX >= pixelWidth || targetY >= pixelHeight) continue;

                    paintTile(targetX, targetY, tileId);
                }
            }

            lastPaintedTiles.current.add(tileKey);
            // Add current palette selection to history on paint
            addRecentStamp(paletteSelection);
        } else if (currentTool === "eraser") {
            paintTile(gridX, gridY, null);
            lastPaintedTiles.current.add(tileKey);
        } else if (currentTool === "fill" && e.type === "mousedown") {
            const fillTileId = paletteSelection.y * tilesPerRow + paletteSelection.x;
            floodFill(gx, gy, fillTileId);
        } else if (currentTool === "marquee") {
            if (e.type === "mousedown") {
                selectionStart.current = { x: gx, y: gy };
                setSelection({ x: gx, y: gy, w: 1, h: 1 });
            } else if (isMouseDown.current && selectionStart.current) {
                const start = selectionStart.current;
                const minX = Math.min(start.x, gx);
                const minY = Math.min(start.y, gy);
                const w = Math.abs(start.x - gx) + 1;
                const h = Math.abs(start.y - gy) + 1;
                setSelection({ x: minX, y: minY, w, h });
            }
        }
    }

    function handleMapMouseDown(e: MouseEvent<HTMLCanvasElement>) {
        if (currentTool !== "marquee") {
            saveCheckpoint();
        }
        isMouseDown.current = true;
        lastPaintedTiles.current.clear();
        handleMapInteraction(e);
    }

    function handleMapMouseMove(e: MouseEvent<HTMLCanvasElement>) {
        if (isMouseDown.current) {
            handleMapInteraction(e);
        }
    }

    function handleMapMouseUp() {
        isMouseDown.current = false;
        lastPaintedTiles.current.clear();
    }

    function handleUploadImage(e: React.ChangeEvent<HTMLInputElement>) {
        const file = e.target.files?.[0];
        if (!file) return;

        const img = new Image();
        img.onload = () => {
            setImage(img);
        };
        img.src = URL.createObjectURL(file);
    }

    function handleSaveMap() {
        const jsonString = JSON.stringify(layers, null, 2);
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "map_data.json";
        a.click();
        URL.revokeObjectURL(url);
    }

    function handleLoadMap(e: React.ChangeEvent<HTMLInputElement>) {
        const file = e.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const json = JSON.parse(ev.target?.result as string);
                if (Array.isArray(json)) {
                    setLayers(json);
                } else if (typeof json === "object" && json !== null) {
                    // Legacy
                    setLayers(draft => {
                        draft[0].data = json;
                    });
                } else {
                    alert("Invalid JSON format");
                }
            } catch (error) {
                alert("Failed to parse JSON");
            }
        };
        reader.readAsText(file);
    }

    function handleExportPng() {
        if (!image) return;

        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = mapSize.width * TILE_WIDTH;
        tempCanvas.height = mapSize.height * TILE_HEIGHT;
        const ctx = tempCanvas.getContext("2d");
        if (!ctx) return;

        layers.forEach(layer => {
            if (!layer.visible) return;
            ctx.globalAlpha = layer.opacity;

            Object.entries(layer.data).forEach(([key, tileData]) => {
                const [gx, gy] = key.split(",").map(Number);
                const drawX = gx * TILE_WIDTH;
                const drawY = gy * TILE_HEIGHT;

                const tilesPerRow = Math.floor(image.width / TILE_WIDTH);
                const srcX = (tileData.tileId % tilesPerRow) * TILE_WIDTH;
                const srcY = Math.floor(tileData.tileId / tilesPerRow) * TILE_HEIGHT;

                ctx.save();
                if (tileData.flipX) {
                    ctx.translate(drawX + TILE_WIDTH, drawY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, 0, 0, TILE_WIDTH, TILE_HEIGHT);
                } else {
                    ctx.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, drawX, drawY, TILE_WIDTH, TILE_HEIGHT);
                }
                ctx.restore();
            });
        });

        const url = tempCanvas.toDataURL("image/png");
        const a = document.createElement("a");
        a.href = url;
        a.download = "map_image.png";
        a.click();
    }

    return (
        <div className="h-screen flex flex-col p-4 box-border">
            <h1 className="text-2xl font-bold mb-4">Map Editor</h1>

            <Toolbar
                mapSize={mapSize}
                setMapSize={setMapSize}
                currentTool={currentTool}
                setCurrentTool={setCurrentTool}
                onSave={handleSaveMap}
                onLoad={handleLoadMap}
                onExport={handleExportPng}
                onUploadImage={handleUploadImage}
            />

            <RecentTiles
                recentStamps={recentStamps}
                onSelect={(stamp) => {
                    setPaletteSelection(stamp);
                    setCurrentTool("brush");
                    addRecentStamp(stamp);
                }}
                image={image}
                activeStamp={paletteSelection}
            />

            <div className="flex gap-4 items-start flex-1 overflow-hidden">
                <div
                    className="flex-none flex flex-col h-full"
                    style={{ width: paletteWidth }}
                >
                    <Palette
                        image={image}
                        selection={paletteSelection}
                        setSelection={setPaletteSelection}
                        zoom={zoomPalette}
                        setZoom={setZoomPalette}
                        isFlipped={isFlipped}
                        onToolChange={() => setCurrentTool("brush")}
                    />
                </div>

                <div
                    className="w-1 cursor-col-resize h-full hover:bg-blue-400 bg-gray-200 flex-none transition-colors"
                    onMouseDown={() => {
                        isResizing.current = true;
                        document.body.style.cursor = "col-resize";
                    }}
                />

                <div className="flex-1 h-full min-w-0 flex flex-col">
                    <h3 className="font-bold mb-2">Map</h3>
                    <MapCanvas
                        layers={layers}
                        mapSize={mapSize}
                        zoom={zoomMap}
                        setZoom={setZoomMap}
                        selection={selection}
                        image={image}
                        currentTool={currentTool}
                        paletteSelection={paletteSelection}
                        isFlipped={isFlipped}
                        onMouseDown={handleMapMouseDown}
                        onMouseMove={handleMapMouseMove}
                        onMouseUp={handleMapMouseUp}
                        onMouseLeave={handleMapMouseUp}
                    />

                    <LayerPanel
                        layers={layers}
                        activeLayerIndex={activeLayerIndex}
                        setActiveLayerIndex={setActiveLayerIndex}
                        onToggleVisibility={(index) => {
                            setLayers(draft => {
                                draft[index].visible = !draft[index].visible;
                            });
                        }}
                    />
                </div>
            </div>
        </div>
    );
}

```

