# Codebase Export: /. folder
Generated on: Wed Dec 24 12:46:13 CET 2025
------------------------------------------------
## Project Structure (/.)
```
.
 |-- pnpm-lock.yaml
 |-- tsconfig.node.json
 |-- index.html
 |-- tsconfig.app.json
 |-- codebase_src_only.txt
 |-- dist
 | |-- index.html
 | |-- assets
 | | |-- index-BGtRhHTc.js
 | | |-- project-dUe5zc86.png
 | | |-- index-r9y5EpkX.css
 |-- node_modules
 | |-- @types
 | | |-- react-dom
 | | |-- node
 | | |-- react
 | |-- globals
 | |-- eslint-scope
 | |-- @eslint
 | | |-- config-array
 | | |-- config-helpers
 | | |-- core
 | | |-- js
 | | |-- object-schema
 | | |-- plugin-kit
 | | |-- eslintrc
 | |-- typescript-eslint
 | |-- @tailwindcss
 | | |-- vite
 | |-- typescript
 | |-- lucide-react
 | |-- @typescript-eslint
 | | |-- project-service
 | | |-- tsconfig-utils
 | | |-- types
 | | |-- typescript-estree
 | | |-- utils
 | | |-- parser
 | | |-- type-utils
 | | |-- scope-manager
 | | |-- eslint-plugin
 | | |-- visitor-keys
 | |-- eslint-visitor-keys
 | |-- eslint-plugin-react-hooks
 | |-- gh-pages
 | |-- use-immer
 | |-- @vitejs
 | | |-- plugin-react-swc
 | |-- react-dom
 | |-- vite
 | |-- immer
 | |-- eslint-plugin-react-refresh
 | |-- eslint
 | |-- tailwindcss
 | |-- react
 | |-- @eslint-community
 | | |-- eslint-utils
 | | |-- regexpp
 |-- README.md
 |-- public
 |-- package.json
 |-- tsconfig.json
 |-- eslint.config.js
 |-- vite.config.ts
 |-- src
 | |-- App.tsx
 | |-- main.tsx
 | |-- App.css
 | |-- index.css
 | |-- types.ts
 | |-- components
 | | |-- editor
 | | | |-- Palette.tsx
 | | | |-- Toolbar.tsx
 | | | |-- LayerPanel.tsx
 | | | |-- MapCanvas.tsx
 | | | |-- RecentTiles.tsx
 | |-- constants.ts
 | |-- hooks
 | | |-- useMapState.ts
 | |-- assets
 | | |-- PathAndObjects.png
 | | |-- project.png
 | | |-- project_old.png
 | | |-- TileSet.png
 | |-- editor
 | | |-- MapEditor.tsx
 |-- codebase.sh
```

## Project Files
---
### File: ./tsconfig.node.json
```json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

```

---
### File: ./index.html
```html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tile Map Editor</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>
```

---
### File: ./tsconfig.app.json
```json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

```

---
### File: ./README.md
```md
# Map Editor

A React-based 2D Tile Map Editor for creating and editing game maps.

## Features

### Tools
- **Brush**: Paint tiles onto the grid.
- **Eraser**: Remove tiles from the grid.
- **Bucket Fill**: Flood fill contiguous areas with a selected tile.
- **Marquee Selection**: Select rectangular areas of the map.
    - **Copy (Cmd+C)**: Copy selection to clipboard.
    - **Paste (Cmd+V)**: Paste clipboard content.
    - **Delete**: Clear selected area.

### Palette & layout
- **Dynamic Palette**: Automatically resizes to fit your uploaded spritesheet.
- **Grid Overlay**: Visual helper on the palette to see tile boundaries (32x32).
- **Split View**: Fixed palette on the left, scrollable map on the right.

### Start & Export
- **Save JSON**: Download your map data (`map_data.json`) to save your progress.
- **Load JSON**: Upload a saved JSON file to restore your map.
- **Export PNG**: Download a clean PNG image of your map (`map_image.png`).

## Setup

1. Install dependencies:
   ```bash
   pnpm install
   ```

2. Run the development server:
   ```bash
   pnpm run dev
   ```

3. Open your browser to the local server address (usually `http://localhost:5173`).

## Usage

1. **Select a Tile**: Click any tile in the Palette on the left.
2. **Draw**: Click and drag on the Map to paint.
3. **Change Tools**: Use the toolbar buttons to switch between Brush, Eraser, Bucket, and Marquee.
4. **Change Spritesheet**: Use the file input in the toolbar to upload a custom spritesheet (`.png`).

```

---
### File: ./package.json
```json
{
  "name": "map-editor",
  "homepage": "https://rezixdev.github.io/map-editor/",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "predeploy": "pnpm run build",
    "deploy": "gh-pages -d dist"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.18",
    "gh-pages": "^6.3.0",
    "immer": "^11.1.0",
    "lucide-react": "^0.562.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "tailwindcss": "^4.1.18",
    "use-immer": "^0.11.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react-swc": "^4.2.2",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  },
  "packageManager": "pnpm@9.15.2+sha512.93e57b0126f0df74ce6bff29680394c0ba54ec47246b9cf321f0121d8d9bb03f750a705f24edc3c1180853afd7c2c3b94196d0a3d53d3e069d9e2793ef11f321"
}
```

---
### File: ./tsconfig.json
```json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

```

---
### File: ./eslint.config.js
```js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])

```

---
### File: ./vite.config.ts
```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import tailwindcss from '@tailwindcss/vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  base: '/map-editor/',
})

```

---
### File: ./src/App.tsx
```tsx
import "./App.css";
import { MapEditor } from "./editor/MapEditor";

function App() {
	return <MapEditor />;
}

export default App;

```

---
### File: ./src/main.tsx
```tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

```

---
### File: ./src/App.css
```css
@import "tailwindcss";

```

---
### File: ./src/index.css
```css

```

---
### File: ./src/types.ts
```ts
export type TileData = { tileId: number; flipX: boolean };
export type Layer = { id: string; name: string; visible: boolean; opacity: number; data: Record<string, TileData> };
export type Tool = "brush" | "eraser" | "fill" | "marquee" | "eyedropper";
export type SelectionRect = { x: number; y: number; w: number; h: number };

export type CustomBrush = {
    width: number;
    height: number;
    data: Record<string, TileData>;
};

```

---
### File: ./src/components/editor/Palette.tsx
```tsx
import React, { useRef, useEffect, type MouseEvent } from "react";
import { type SelectionRect } from "../../types";
import { TILE_WIDTH, TILE_HEIGHT } from "../../constants";

type PaletteProps = {
    image: HTMLImageElement | null;
    selection: SelectionRect;
    setSelection: React.Dispatch<React.SetStateAction<SelectionRect>>;
    zoom: number;
    setZoom: React.Dispatch<React.SetStateAction<number>>;
    isFlipped: boolean;
    onToolChange: () => void;
};

export function Palette({ image, selection, setSelection, zoom, setZoom, isFlipped, onToolChange }: PaletteProps) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const isMouseDown = useRef(false);
    const selectionStart = useRef<{ x: number; y: number } | null>(null);

    function renderPalette() {
        const canvas = canvasRef.current;
        const context = canvas?.getContext("2d");
        if (!canvas || !context || !image) return;

        // Resize canvas logic:
        const logicalWidth = image.width;
        const logicalHeight = image.height;

        if (canvas.width !== logicalWidth || canvas.height !== logicalHeight) {
            canvas.width = logicalWidth;
            canvas.height = logicalHeight;
        }

        context.imageSmoothingEnabled = false;
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Source Image
        context.drawImage(image, 0, 0);

        // Draw Grid Overlay on Palette
        context.beginPath();
        // Vertical lines
        for (let i = 0; i <= image.width; i += TILE_WIDTH) {
            context.moveTo(i, 0);
            context.lineTo(i, image.height);
        }
        // Horizontal lines
        for (let i = 0; i <= image.height; i += TILE_HEIGHT) {
            context.moveTo(0, i);
            context.lineTo(image.width, i);
        }
        context.strokeStyle = "rgba(0,0,0, 0.2)";
        context.lineWidth = 1;
        context.stroke();

        // Draw Selection Box on Palette
        const drawX = selection.x * TILE_WIDTH;
        const drawY = selection.y * TILE_HEIGHT;
        const drawW = selection.w * TILE_WIDTH;
        const drawH = selection.h * TILE_HEIGHT;

        context.beginPath();
        context.strokeStyle = "white";
        context.lineWidth = 2;
        context.setLineDash([4, 4]);
        context.strokeRect(drawX, drawY, drawW, drawH);

        context.strokeStyle = "black";
        context.lineDashOffset = 4;
        context.strokeRect(drawX, drawY, drawW, drawH);

        context.setLineDash([]);
        context.lineDashOffset = 0;
    }

    useEffect(() => {
        renderPalette();
    }, [image, selection, zoom]);

    function handleMouseDown(e: MouseEvent<HTMLCanvasElement>) {
        const canvas = canvasRef.current;
        if (!canvas) return;

        isMouseDown.current = true;
        const x = e.nativeEvent.offsetX / zoom;
        const y = e.nativeEvent.offsetY / zoom;

        const tileX = Math.floor(x / TILE_WIDTH);
        const tileY = Math.floor(y / TILE_HEIGHT);

        selectionStart.current = { x: tileX, y: tileY };
        setSelection({ x: tileX, y: tileY, w: 1, h: 1 });

        onToolChange();
    }

    function handleMouseMove(e: MouseEvent<HTMLCanvasElement>) {
        if (!isMouseDown.current || !selectionStart.current) return;

        const canvas = canvasRef.current;
        if (!canvas || !image) return;

        const x = e.nativeEvent.offsetX / zoom;
        const y = e.nativeEvent.offsetY / zoom;

        // Constrain to image bounds
        const tileX = Math.max(0, Math.min(Math.floor(x / TILE_WIDTH), Math.floor(image.width / TILE_WIDTH) - 1));
        const tileY = Math.max(0, Math.min(Math.floor(y / TILE_HEIGHT), Math.floor(image.height / TILE_HEIGHT) - 1));

        const start = selectionStart.current;
        const minX = Math.min(start.x, tileX);
        const minY = Math.min(start.y, tileY);
        const w = Math.abs(start.x - tileX) + 1;
        const h = Math.abs(start.y - tileY) + 1;

        setSelection({ x: minX, y: minY, w, h });
    }

    function handleMouseUp() {
        isMouseDown.current = false;
    }

    function handleWheel(e: React.WheelEvent) {
        if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            setZoom((z) => {
                const newZoom = z - e.deltaY * 0.001;
                // Clamp between 0.25x and 4x
                return Math.max(0.25, Math.min(4, newZoom));
            });
        }
    }

    return (
        <div className="flex-none flex flex-col h-full" style={{ width: "100%" }}>
            <h3 className="font-bold mb-2">Palette</h3>
            <div className="border border-gray-400 bg-gray-50 flex-1 overflow-auto">
                <canvas
                    ref={canvasRef}
                    className="cursor-pointer block origin-top-left"
                    style={{
                        width: image ? image.width * zoom : undefined,
                        height: image ? image.height * zoom : undefined,
                        imageRendering: "pixelated",
                    }}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onWheel={handleWheel}
                    aria-label="Palette Grid - Use arrow keys to navigate"
                    tabIndex={0}
                />
            </div>
            <div className="mt-2 text-sm text-gray-500">
                Drag to select multiple tiles.
                <br />
                Shortcuts: B (Brush), E (Eraser), F (Fill), X (Flip)
            </div>
            <div
                className={`mt-2 p-1 text-xs text-center border rounded ${isFlipped ? "bg-blue-100 border-blue-500 font-bold" : "bg-gray-100 text-gray-400"}`}
            >
                Flip X: {isFlipped ? "ON" : "OFF"}
            </div>
        </div>
    );
}

```

---
### File: ./src/components/editor/Toolbar.tsx
```tsx
import React from "react";
import { type Tool } from "../../types";

type ToolbarProps = {
    mapSize: { width: number; height: number };
    setMapSize: React.Dispatch<React.SetStateAction<{ width: number; height: number }>>;
    currentTool: Tool;
    setCurrentTool: React.Dispatch<React.SetStateAction<Tool>>;
    onSave: () => void;
    onLoad: (e: React.ChangeEvent<HTMLInputElement>) => void;
    onExport: () => void;
    onUploadImage: (e: React.ChangeEvent<HTMLInputElement>) => void;
};

export function Toolbar({
    mapSize,
    setMapSize,
    currentTool,
    setCurrentTool,
    onSave,
    onLoad,
    onExport,
    onUploadImage,
}: ToolbarProps) {
    return (
        <div className="flex flex-wrap gap-4 items-center mb-4 flex-none">
            <div className="flex gap-2 items-center bg-gray-100 p-2 rounded">
                <label className="text-sm">
                    W:
                    <input
                        type="number"
                        className="ml-1 w-16 p-1 rounded border"
                        value={mapSize.width}
                        onChange={(e) => setMapSize((prev) => ({ ...prev, width: Number(e.target.value) }))}
                    />
                </label>
                <label className="text-sm">
                    H:
                    <input
                        type="number"
                        className="ml-1 w-16 p-1 rounded border"
                        value={mapSize.height}
                        onChange={(e) => setMapSize((prev) => ({ ...prev, height: Number(e.target.value) }))}
                    />
                </label>
            </div>
            <input type="file" accept="image/png" className="block" onChange={onUploadImage} />

            <div className="flex gap-1 bg-gray-100 p-1 rounded">
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "brush" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("brush")}
                    title="Shortcut: B"
                >
                    Brush
                </button>
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "eraser" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("eraser")}
                    title="Shortcut: E"
                >
                    Eraser
                </button>
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "fill" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("fill")}
                    title="Shortcut: F or G"
                >
                    Fill
                </button>
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "marquee" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("marquee")}
                >
                    Marquee
                </button>
                <button
                    className={`px-3 py-1 rounded text-sm ${currentTool === "eyedropper" ? "bg-blue-600 text-white" : "bg-white text-gray-700"}`}
                    onClick={() => setCurrentTool("eyedropper")}
                    title="Shortcut: I (Alt+Click to quick-pick)"
                >
                    Eyedropper
                </button>
            </div>

            <div className="flex gap-2 p-2 bg-gray-100 rounded border border-gray-300">
                <button
                    className="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700"
                    onClick={onSave}
                >
                    Save JSON
                </button>
                <label className="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700 cursor-pointer">
                    Load JSON
                    <input type="file" accept=".json" className="hidden" onChange={onLoad} />
                </label>
                <button
                    className="px-3 py-1 bg-purple-600 text-white rounded text-sm hover:bg-purple-700"
                    onClick={onExport}
                >
                    Export PNG
                </button>
            </div>
        </div>
    );
}

```

---
### File: ./src/components/editor/LayerPanel.tsx
```tsx
import { useState, useRef, useEffect } from "react";
import { type Layer } from "../../types";

type LayerPanelProps = {
    layers: Layer[];
    activeLayerIndex: number;
    setActiveLayerIndex: (index: number) => void;
    onToggleVisibility: (index: number) => void;
    onOpacityChange: (index: number, opacity: number) => void;
    onMoveLayer: (index: number, direction: 'up' | 'down') => void;
    onAddLayer: () => void;
    onRemoveLayer: (index: number) => void;
    onRenameLayer: (index: number, newName: string) => void;
};

export function LayerPanel({
    layers,
    activeLayerIndex,
    setActiveLayerIndex,
    onToggleVisibility,
    onOpacityChange,
    onMoveLayer,
    onAddLayer,
    onRemoveLayer,
    onRenameLayer
}: LayerPanelProps) {
    const [editingIndex, setEditingIndex] = useState<number | null>(null);
    const [editName, setEditName] = useState("");
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (editingIndex !== null && inputRef.current) {
            inputRef.current.focus();
        }
    }, [editingIndex]);

    function startEditing(index: number, currentName: string) {
        setEditingIndex(index);
        setEditName(currentName);
    }

    function saveEditing() {
        if (editingIndex !== null) {
            if (editName.trim()) {
                onRenameLayer(editingIndex, editName.trim());
            }
            setEditingIndex(null);
            setEditName("");
        }
    }

    function handleKeyDown(e: React.KeyboardEvent) {
        if (e.key === "Enter") {
            saveEditing();
        } else if (e.key === "Escape") {
            setEditingIndex(null);
        }
    }

    return (
        <div className="h-48 border-t border-gray-300 bg-gray-50 p-2 flex flex-col">
            <div className="flex items-center justify-between mb-2">
                <h4 className="text-sm font-bold">Layers</h4>
                <button
                    onClick={onAddLayer}
                    className="px-2 py-0.5 bg-blue-500 text-white rounded text-xs hover:bg-blue-600"
                    title="Add New Layer"
                >
                    + Add
                </button>
            </div>
            <div className="flex-1 overflow-auto space-y-1">
                {layers.map((layer, index) => (
                    <div
                        key={layer.id}
                        className={`flex flex-col p-2 rounded cursor-pointer ${activeLayerIndex === index ? "bg-blue-100 ring-1 ring-blue-500" : "hover:bg-gray-100"}`}
                        onClick={() => setActiveLayerIndex(index)}
                    >
                        <div className="flex items-center justify-between mb-1">
                            <div className="flex items-center flex-1 min-w-0">
                                <button
                                    className="mr-2 text-gray-500 hover:text-black flex-none"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onToggleVisibility(index);
                                    }}
                                >
                                    {layer.visible ? "üëÅÔ∏è" : "üö´"}
                                </button>

                                {editingIndex === index ? (
                                    <input
                                        ref={inputRef}
                                        type="text"
                                        value={editName}
                                        onChange={(e) => setEditName(e.target.value)}
                                        onBlur={saveEditing}
                                        onKeyDown={handleKeyDown}
                                        onClick={(e) => e.stopPropagation()}
                                        className="text-sm font-medium border border-blue-500 rounded px-1 w-full"
                                    />
                                ) : (
                                    <span
                                        className={`text-sm font-medium select-none truncate ${!layer.visible && "text-gray-400"}`}
                                        onDoubleClick={(e) => {
                                            e.stopPropagation();
                                            startEditing(index, layer.name);
                                        }}
                                        title="Double click to rename"
                                    >{layer.name}</span>
                                )}
                            </div>
                            <div className="flex items-center space-x-1 ml-2">
                                <button
                                    className="px-1 text-xs bg-gray-200 hover:bg-gray-300 rounded disabled:opacity-30"
                                    disabled={layers.length <= 1}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        if (confirm(`Delete layer "${layer.name}"?`)) {
                                            onRemoveLayer(index);
                                        }
                                    }}
                                    title="Delete Layer"
                                >
                                    üóëÔ∏è
                                </button>
                                <button
                                    className="px-1 text-xs bg-gray-200 hover:bg-gray-300 rounded disabled:opacity-30"
                                    disabled={index === layers.length - 1}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onMoveLayer(index, 'up');
                                    }}
                                    title="Move Up"
                                >
                                    ‚Üì
                                </button>
                                <button
                                    className="px-1 text-xs bg-gray-200 hover:bg-gray-300 rounded disabled:opacity-30"
                                    disabled={index === 0}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onMoveLayer(index, 'down');
                                    }}
                                    title="Move Down"
                                >
                                    ‚Üë
                                </button>
                            </div>
                        </div>

                        <div className="flex items-center space-x-2" onClick={(e) => e.stopPropagation()}>
                            <span className="text-xs text-gray-500 w-12">Opacity:</span>
                            <input
                                type="range"
                                min="0"
                                max="1"
                                step="0.1"
                                value={layer.opacity}
                                onChange={(e) => onOpacityChange(index, parseFloat(e.target.value))}
                                className="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                            />
                            <span className="text-xs text-gray-500 w-8 text-right">{Math.round(layer.opacity * 100)}%</span>
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
}

```

---
### File: ./src/components/editor/MapCanvas.tsx
```tsx
import { useRef, useEffect, type MouseEvent } from "react";
import { type Layer, type SelectionRect, type Tool, type CustomBrush } from "../../types";
import { TILE_WIDTH, TILE_HEIGHT } from "../../constants";

type MapCanvasProps = {
    layers: Layer[];
    mapSize: { width: number; height: number };
    zoom: number;
    setZoom: React.Dispatch<React.SetStateAction<number>>;
    selection: SelectionRect | null;
    image: HTMLImageElement | null;
    currentTool: Tool;
    paletteSelection: SelectionRect;
    isFlipped: boolean;
    customBrush: CustomBrush | null;
    cameraOffset: { x: number; y: number };
    onMouseDown: (e: MouseEvent<HTMLCanvasElement>) => void;
    onMouseMove: (e: MouseEvent<HTMLCanvasElement>) => void;
    onMouseUp: () => void;
    onMouseLeave: () => void;
};

export function MapCanvas({
    layers,
    mapSize,
    zoom,
    setZoom,
    selection,
    image,

    currentTool,
    paletteSelection,
    isFlipped,
    customBrush,
    cameraOffset,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    onMouseLeave,
}: MapCanvasProps) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const mousePosRef = useRef<{ x: number; y: number } | null>(null);
    const reqIdRef = useRef<number | null>(null);

    function renderMap() {
        const canvas = canvasRef.current;
        const context = canvas?.getContext("2d");
        if (!canvas || !context || !image) return;

        // Resize map canvas
        const logicalWidth = mapSize.width * TILE_WIDTH;
        const logicalHeight = mapSize.height * TILE_HEIGHT;

        if (canvas.width !== logicalWidth || canvas.height !== logicalHeight) {
            canvas.width = logicalWidth;
            canvas.height = logicalHeight;
        }

        context.imageSmoothingEnabled = false;
        context.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Map Tiles (Layered)
        context.save();
        context.translate(cameraOffset.x, cameraOffset.y);

        layers.forEach((layer) => {
            if (!layer.visible) return;

            context.save();
            context.globalAlpha = layer.opacity;

            Object.entries(layer.data).forEach(([key, tileData]) => {
                const [gx, gy] = key.split(",").map(Number);
                const drawX = gx * TILE_WIDTH;
                const drawY = gy * TILE_HEIGHT;

                const tilesPerRow = Math.floor(image.width / TILE_WIDTH);
                const srcX = (tileData.tileId % tilesPerRow) * TILE_WIDTH;
                const srcY = Math.floor(tileData.tileId / tilesPerRow) * TILE_HEIGHT;

                context.save();
                if (tileData.flipX) {
                    context.translate(drawX + TILE_WIDTH, drawY);
                    context.scale(-1, 1);
                    context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, 0, 0, TILE_WIDTH, TILE_HEIGHT);
                } else {
                    context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, drawX, drawY, TILE_WIDTH, TILE_HEIGHT);
                }
                context.restore();
            });

            context.restore();
        });
        context.restore();

        // 2. Draw Grid (with offset)
        context.save();
        context.translate(cameraOffset.x, cameraOffset.y);
        context.beginPath();
        for (let i = 0; i <= mapSize.width; i++) {
            context.moveTo(i * TILE_WIDTH, 0);
            context.lineTo(i * TILE_WIDTH, logicalHeight);
        }
        for (let i = 0; i <= mapSize.height; i++) {
            context.moveTo(0, i * TILE_HEIGHT);
            context.lineTo(logicalWidth, i * TILE_HEIGHT);
        }
        context.strokeStyle = "rgba(0,0,0, 0.4)";
        context.lineWidth = 1;
        context.stroke();
        context.restore();

        // 3. Draw Selection Marquee (with offset)
        if (selection) {
            context.save();
            context.translate(cameraOffset.x, cameraOffset.y);
            const selX = selection.x * TILE_WIDTH;
            const selY = selection.y * TILE_HEIGHT;
            const selW = selection.w * TILE_WIDTH;
            const selH = selection.h * TILE_HEIGHT;

            // Fill
            context.fillStyle = "rgba(0, 140, 255, 0.2)";
            context.fillRect(selX, selY, selW, selH);

            // Border
            context.beginPath();
            context.strokeStyle = "white";
            context.lineWidth = 2;
            context.setLineDash([4, 4]);
            context.strokeRect(selX, selY, selW, selH);

            context.strokeStyle = "black";
            context.setLineDash([4, 4]);
            context.lineDashOffset = 4;
            context.strokeRect(selX, selY, selW, selH);

            context.setLineDash([]);
            context.lineDashOffset = 0;
            context.restore();
        }

        // 4. Draw Ghost/Hover Cursor
        if (mousePosRef.current) {
            // Apply offset to ghost rendering
            context.save();
            context.translate(cameraOffset.x, cameraOffset.y);

            const gridX = Math.floor((mousePosRef.current.x - cameraOffset.x) / TILE_WIDTH) * TILE_WIDTH;
            const gridY = Math.floor((mousePosRef.current.y - cameraOffset.y) / TILE_HEIGHT) * TILE_HEIGHT;

            // Draw Ghost Tile
            if (currentTool === "brush" || currentTool === "fill") {
                context.globalAlpha = 0.5;

                if (customBrush && currentTool === "brush") {
                    // Render Custom Brush
                    Object.entries(customBrush.data).forEach(([key, tileData]) => {
                        const [dx, dy] = key.split(",").map(Number);

                        // Mirror ghost layout
                        const finalDx = isFlipped ? (customBrush.width - 1 - dx) : dx;

                        const drawX = gridX + (finalDx * TILE_WIDTH);
                        const drawY = gridY + (dy * TILE_HEIGHT);

                        const tilesPerRow = Math.floor(image.width / TILE_WIDTH);
                        const srcX = (tileData.tileId % tilesPerRow) * TILE_WIDTH;
                        const srcY = Math.floor(tileData.tileId / tilesPerRow) * TILE_HEIGHT;

                        context.save();
                        // Combined Flip Logic: Source Flip XOR Global Flip
                        const combinedFlip = tileData.flipX !== isFlipped;

                        if (combinedFlip) {
                            context.translate(drawX + TILE_WIDTH, drawY);
                            context.scale(-1, 1);
                            context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, 0, 0, TILE_WIDTH, TILE_HEIGHT);
                        } else {
                            context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, drawX, drawY, TILE_WIDTH, TILE_HEIGHT);
                        }
                        context.restore();
                    });
                } else if (currentTool === "fill") {
                    // Simple 1x1 ghost for Fill tool
                    const srcX = paletteSelection.x * TILE_WIDTH;
                    const srcY = paletteSelection.y * TILE_HEIGHT;

                    context.save();
                    if (isFlipped) {
                        context.translate(gridX + TILE_WIDTH, gridY);
                        context.scale(-1, 1);
                        context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, 0, 0, TILE_WIDTH, TILE_HEIGHT);
                    } else {
                        context.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, gridX, gridY, TILE_WIDTH, TILE_HEIGHT);
                    }
                    context.restore();
                }

                context.globalAlpha = 1.0;
            }

            // Draw Cursor Border
            if (currentTool === "brush") {
                const drawW = paletteSelection.w * TILE_WIDTH;
                const drawH = paletteSelection.h * TILE_HEIGHT;

                context.beginPath();
                context.strokeStyle = "white";
                context.lineWidth = 1;
                context.setLineDash([4, 4]);
                context.strokeRect(gridX, gridY, drawW, drawH);

                context.strokeStyle = "black";
                context.lineDashOffset = 4;
                context.strokeRect(gridX, gridY, drawW, drawH);
                context.setLineDash([]);
                context.lineDashOffset = 0;
            } else if (currentTool === "eraser" || currentTool === "fill") {
                // Single tile hover (Eraser, Fill)
                context.beginPath();
                context.strokeStyle = "white";
                context.lineWidth = 1;
                context.setLineDash([4, 4]);
                context.strokeRect(gridX, gridY, TILE_WIDTH, TILE_HEIGHT);

                context.strokeStyle = "black";
                context.lineDashOffset = 4;
                context.strokeRect(gridX, gridY, TILE_WIDTH, TILE_HEIGHT);
                context.setLineDash([]);
                context.lineDashOffset = 0;
            }
            context.restore();
        }
    }

    useEffect(() => {
        function loop() {
            renderMap();
            reqIdRef.current = requestAnimationFrame(loop);
        }
        loop();
        return () => {
            if (reqIdRef.current) cancelAnimationFrame(reqIdRef.current);
        };
    }, [layers, selection, mapSize, zoom, image, paletteSelection, currentTool, isFlipped, cameraOffset, customBrush]);

    function handleInternalMouseMove(e: MouseEvent<HTMLCanvasElement>) {
        // Calculate hover pos
        const x = e.nativeEvent.offsetX / zoom;
        const y = e.nativeEvent.offsetY / zoom;
        mousePosRef.current = { x, y };

        // Propagate
        onMouseMove(e);
    }

    function handleInternalMouseLeave() {
        mousePosRef.current = null;
        onMouseLeave();
    }

    function handleWheel(e: React.WheelEvent) {
        if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            setZoom((z) => {
                const newZoom = z - e.deltaY * 0.001;
                return Math.max(0.25, Math.min(4, newZoom));
            });
        }
    }

    return (
        <div className="border-2 border-gray-300 bg-gray-100 flex-1 overflow-auto relative rounded">
            <canvas
                ref={canvasRef}
                className="block bg-white shadow-sm origin-top-left"
                style={{
                    width: mapSize.width * TILE_WIDTH * zoom,
                    height: mapSize.height * TILE_HEIGHT * zoom,
                    imageRendering: "pixelated",
                    cursor: ((): string => {
                        switch (currentTool) {
                            case "brush":
                            case "eraser":
                            case "fill":
                                return "none"; // We render our own cursor
                            case "eyedropper":
                                return "crosshair";
                            case "marquee":
                                return "crosshair"; // Standard selection cursor
                            default:
                                return "default";
                        }
                    })()
                }}
                onMouseDown={onMouseDown}
                onMouseMove={handleInternalMouseMove}
                onMouseUp={onMouseUp}
                onMouseLeave={handleInternalMouseLeave}
                onWheel={handleWheel}
                aria-label="Map Grid"
                tabIndex={0}
            ></canvas>
        </div>
    );
}

```

---
### File: ./src/components/editor/RecentTiles.tsx
```tsx
import { useRef, useEffect } from "react";
import { type SelectionRect } from "../../types";
import { TILE_WIDTH, TILE_HEIGHT } from "../../constants";

type RecentTilesProps = {
    recentStamps: SelectionRect[];
    onSelect: (stamp: SelectionRect) => void;
    image: HTMLImageElement | null;
    activeStamp: SelectionRect;
};

export function RecentTiles({ recentStamps, onSelect, image, activeStamp }: RecentTilesProps) {
    return (
        <div className="flex gap-2 p-2 bg-gray-50 border-b overflow-x-auto h-12 items-center">
            <span className="text-xs font-bold text-gray-500 mr-2 flex-none">History:</span>
            {recentStamps.map((stamp, i) => (
                <TilePreview
                    key={i}
                    stamp={stamp}
                    image={image}
                    onClick={() => onSelect(stamp)}
                    isActive={
                        activeStamp.x === stamp.x &&
                        activeStamp.y === stamp.y &&
                        activeStamp.w === stamp.w &&
                        activeStamp.h === stamp.h
                    }
                />
            ))}
            {recentStamps.length === 0 && (
                <span className="text-xs text-gray-400 italic">Select stamps to see history...</span>
            )}
        </div>
    );
}

function TilePreview({
    stamp,
    image,
    onClick,
    isActive,
}: {
    stamp: SelectionRect;
    image: HTMLImageElement | null;
    onClick: () => void;
    isActive: boolean;
}) {
    const canvasRef = useRef<HTMLCanvasElement>(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas?.getContext("2d");
        if (!canvas || !ctx || !image) return;

        // Scale down if large
        const stampW = stamp.w * TILE_WIDTH;
        const stampH = stamp.h * TILE_HEIGHT;

        // Fit to 32x32 max
        const scale = Math.min(32 / stampW, 32 / stampH);

        ctx.clearRect(0, 0, 32, 32);
        ctx.imageSmoothingEnabled = false;

        const drawW = stampW * scale;
        const drawH = stampH * scale;

        // Center
        const offsetX = (32 - drawW) / 2;
        const offsetY = (32 - drawH) / 2;

        ctx.drawImage(
            image,
            stamp.x * TILE_WIDTH,
            stamp.y * TILE_HEIGHT,
            stampW,
            stampH,
            offsetX,
            offsetY,
            drawW,
            drawH
        );

    }, [stamp, image]);

    return (
        <div
            onClick={onClick}
            className={`w-8 h-8 border rounded flex-none cursor-pointer hover:border-blue-400 bg-white ${isActive ? "border-blue-600 ring-1 ring-blue-600" : "border-gray-300"
                }`}
            title={`Stamp ${stamp.x},${stamp.y} (${stamp.w}x${stamp.h})`}
        >
            <canvas ref={canvasRef} width={32} height={32} className="w-full h-full" />
        </div>
    );
}

```

---
### File: ./src/constants.ts
```ts
export const TILE_WIDTH = 32;
export const TILE_HEIGHT = 32;

```

---
### File: ./src/hooks/useMapState.ts
```ts
import { useState, useEffect, useRef, useCallback } from "react";
import { useImmer } from "use-immer";
import { type Layer, type SelectionRect } from "../types";

const STORAGE_KEY = "tile_craft_editor_v1";

// 4.5 MB Limit (Safe margin for 5MB localStorage)
const STORAGE_SIZE_LIMIT = 4.5 * 1024 * 1024;

const INITIAL_LAYERS: Layer[] = [
    { id: "ground", name: "Ground", visible: true, opacity: 1, data: {} },
    { id: "decor", name: "Decoration", visible: true, opacity: 1, data: {} },
    { id: "collision", name: "Collision", visible: true, opacity: 0.5, data: {} },
];

const INITIAL_MAP_SIZE = { width: 64, height: 16 };

export function useMapState() {
    const [layers, setLayers] = useImmer<Layer[]>(INITIAL_LAYERS);
    const [mapSize, setMapSize] = useState(INITIAL_MAP_SIZE);
    const [recentStamps, setRecentStamps] = useImmer<SelectionRect[]>([]);

    // History Stacks
    const historyPast = useRef<Layer[][]>([]);
    const historyFuture = useRef<Layer[][]>([]);

    const isHydrated = useRef(false);
    const saveTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

    // Hydration
    useEffect(() => {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (raw) {
                const data = JSON.parse(raw);
                if (data && Array.isArray(data.layers) && data.mapSize) {
                    setLayers(data.layers);
                    setMapSize(data.mapSize);
                    if (data.recentStamps) {
                        setRecentStamps(data.recentStamps);
                    }
                } else if (Array.isArray(data)) {
                    // Legacy fallback if just layers were saved
                    setLayers(data);
                }
            }
        } catch (e) {
            console.error("Failed to hydrate map state", e);
        } finally {
            isHydrated.current = true;
        }
    }, [setLayers, setRecentStamps]);

    // Persistence
    useEffect(() => {
        if (!isHydrated.current) return;

        if (saveTimeoutRef.current) {
            clearTimeout(saveTimeoutRef.current);
        }

        saveTimeoutRef.current = setTimeout(() => {
            try {
                const state = {
                    layers,
                    mapSize,
                    recentStamps
                };
                const json = JSON.stringify(state);

                if (json.length > STORAGE_SIZE_LIMIT) {
                    console.warn(`Map data exceeds storage limit (${(json.length / 1024 / 1024).toFixed(2)}MB)`);
                    return;
                }

                localStorage.setItem(STORAGE_KEY, json);
            } catch (e) {
                console.error("Failed to save map state", e);
            }
        }, 500); // 500ms debounce

        return () => {
            if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
        };
    }, [layers, mapSize, recentStamps]);

    const addRecentStamp = useCallback((stamp: SelectionRect) => {
        setRecentStamps(draft => {
            // Remove exact duplicate
            const index = draft.findIndex(s =>
                s.x === stamp.x && s.y === stamp.y && s.w === stamp.w && s.h === stamp.h
            );
            if (index !== -1) {
                draft.splice(index, 1);
            }
            // Add to front
            draft.unshift(stamp);
            // Limit to 10
            if (draft.length > 10) {
                draft.pop();
            }
        });
    }, [setRecentStamps]);

    // Checkpoint
    const saveCheckpoint = useCallback(() => {
        historyPast.current.push(layers);
        if (historyPast.current.length > 50) historyPast.current.shift();
        historyFuture.current = [];
    }, [layers]);

    // Undo
    const performUndo = useCallback(() => {
        if (historyPast.current.length === 0) return;
        const previous = historyPast.current.pop();
        if (previous) {
            historyFuture.current.push(layers);
            setLayers(previous);
        }
    }, [layers, setLayers]);

    // Redo
    const performRedo = useCallback(() => {
        if (historyFuture.current.length === 0) return;
        const next = historyFuture.current.pop();
        if (next) {
            historyPast.current.push(layers);
            setLayers(next);
        }
    }, [layers, setLayers]);

    // Clear history on map size change to avoid incongruity? 
    // Or just let it be. Usually resizing doesn't break tile data directly but 
    // for simplicity we won't clear history.

    const addLayer = useCallback((baseName: string) => {
        saveCheckpoint();
        setLayers(draft => {
            // Uniqueness check
            let name = baseName;
            let counter = 1;
            while (draft.some(l => l.name === name)) {
                name = `${baseName} (${counter})`;
                counter++;
            }

            const newId = crypto.randomUUID();
            draft.push({
                id: newId,
                name: name,
                visible: true,
                opacity: 1,
                data: {}
            });
        });
    }, [setLayers, saveCheckpoint]);

    const removeLayer = useCallback((index: number) => {
        // Prevent deleting last layer
        if (layers.length <= 1) return;
        saveCheckpoint();
        setLayers(draft => {
            draft.splice(index, 1);
        });
    }, [layers.length, setLayers, saveCheckpoint]);

    const renameLayer = useCallback((index: number, newName: string) => {
        setLayers(draft => {
            // Basic uniqueness check: if exists, don't rename (or could suffix).
            // For UI simplicity, we'll strict reject or auto-suffix.
            // Let's auto-suffix to be safe and easy.
            let name = newName;
            let counter = 1;
            // Check against OTHER layers
            while (draft.some((l, i) => i !== index && l.name === name)) {
                name = `${newName} (${counter})`;
                counter++;
            }
            draft[index].name = name;
        });
    }, [setLayers]);


    return {
        layers,
        setLayers,
        mapSize,
        setMapSize,

        recentStamps,
        addRecentStamp,
        saveCheckpoint,
        performUndo,
        performRedo,

        addLayer,
        removeLayer,
        renameLayer
    };
}

```

---
### File: ./src/editor/MapEditor.tsx
```tsx
import { useRef, useState, useEffect, type MouseEvent } from "react";
import spritesheet from "../assets/project.png";
import { useMapState } from "../hooks/useMapState";
import { type TileData, type Tool, type SelectionRect, type CustomBrush } from "../types";
import { TILE_WIDTH, TILE_HEIGHT } from "../constants";
import { LayerPanel } from "../components/editor/LayerPanel";
import { Toolbar } from "../components/editor/Toolbar";
import { Palette } from "../components/editor/Palette";
import { RecentTiles } from "../components/editor/RecentTiles";
import { MapCanvas } from "../components/editor/MapCanvas";

export function MapEditor() {
    const {
        layers,
        setLayers,
        mapSize,
        setMapSize,
        saveCheckpoint,
        performUndo,

        performRedo,
        recentStamps,
        addRecentStamp,
        addLayer,
        removeLayer,
        renameLayer
    } = useMapState();

    const [image, setImage] = useState<HTMLImageElement | null>(null);
    const [paletteWidth, setPaletteWidth] = useState(280);
    const [zoomMap, setZoomMap] = useState(1);
    const [zoomPalette, setZoomPalette] = useState(1);
    const [cameraOffset, setCameraOffset] = useState({ x: 0, y: 0 });
    const [isFlipped, setIsFlipped] = useState(false);
    const [paletteSelection, setPaletteSelection] = useState<SelectionRect>({ x: 0, y: 0, w: 1, h: 1 });
    const [activeLayerIndex, setActiveLayerIndex] = useState(0);
    const [currentTool, setCurrentTool] = useState<Tool>("brush");
    const [selection, setSelection] = useState<SelectionRect | null>(null);

    const [clipboard, setClipboard] = useState<Record<string, TileData> | null>(null);
    const [customBrush, setCustomBrush] = useState<CustomBrush | null>(null);


    const isMouseDown = useRef(false);
    const isPanning = useRef(false);
    const isSpacePressed = useRef(false);
    const isResizing = useRef(false);
    const lastPaintedTiles = useRef<Set<string>>(new Set());
    const selectionStart = useRef<{ x: number; y: number } | null>(null);




    function updatePaletteSelection(newSelection: SelectionRect) {
        setPaletteSelection(newSelection);

        if (!image) return;
        const tilesPerRow = Math.floor(image.width / TILE_WIDTH);
        const brushData: Record<string, TileData> = {};

        for (let dy = 0; dy < newSelection.h; dy++) {
            for (let dx = 0; dx < newSelection.w; dx++) {
                const srcX = newSelection.x + dx;
                const srcY = newSelection.y + dy;
                const tileId = srcY * tilesPerRow + srcX;
                brushData[`${dx},${dy}`] = { tileId, flipX: false };
            }
        }

        setCustomBrush({
            width: newSelection.w,
            height: newSelection.h,
            data: brushData
        });
    }

    function sampleArea(area: { x: number, y: number, w: number, h: number }) {
        if (!image) return;

        const brushData: Record<string, TileData> = {};
        let foundTiles = false;
        let minX = Infinity;
        let minY = Infinity;

        // 1. Capture Data
        for (let dy = 0; dy < area.h; dy++) {
            for (let dx = 0; dx < area.w; dx++) {
                const mapX = area.x + dx;
                const mapY = area.y + dy;
                const key = `${mapX},${mapY}`;

                let tile = layers[activeLayerIndex].data[key];
                if (!tile) {
                    for (let i = layers.length - 1; i >= 0; i--) {
                        if (!layers[i].visible) continue;
                        if (layers[i].data[key]) {
                            tile = layers[i].data[key];
                            break;
                        }
                    }
                }

                if (tile) {
                    brushData[`${dx},${dy}`] = tile;
                    foundTiles = true;
                    if (dx < minX) minX = dx;
                    if (dy < minY) minY = dy;
                }
            }
        }

        if (foundTiles) {
            // Trim empty space from top-left (smart anchor)
            const trimmedData: Record<string, TileData> = {};
            let maxWidth = 0;
            let maxHeight = 0;

            Object.entries(brushData).forEach(([key, tile]) => {
                const [dx, dy] = key.split(",").map(Number);
                const newX = dx - minX;
                const newY = dy - minY;
                trimmedData[`${newX},${newY}`] = tile;
                if (newX >= maxWidth) maxWidth = newX;
                if (newY >= maxHeight) maxHeight = newY;
            });

            const newBrush: CustomBrush = {
                width: maxWidth + 1,
                height: maxHeight + 1,
                data: trimmedData
            };

            setCustomBrush(newBrush);
            setCurrentTool("brush");
            setSelection(null);

            // Retroactive History Support
            // Try to see if this matches a contiguous spritesheet rect for the palette/history
            // If complex/scattered, we skip adding to history for now.
            const firstTile = Object.values(trimmedData)[0];
            if (firstTile) {
                // Check if *all* tiles align contiguously on spritesheet relative to the first
                const tilesPerRow = Math.floor(image.width / TILE_WIDTH);
                const firstId = firstTile.tileId;
                const startSrcX = firstId % tilesPerRow;
                const startSrcY = Math.floor(firstId / tilesPerRow);

                let isContiguous = true;
                for (let y = 0; y < newBrush.height; y++) {
                    for (let x = 0; x < newBrush.width; x++) {
                        const t = trimmedData[`${x},${y}`];
                        if (!t) continue; // Gaps are allowed in custom brush, but might break rect check if strictly rect

                        const expectedId = (startSrcY + y) * tilesPerRow + (startSrcX + x);
                        if (t.tileId !== expectedId) {
                            isContiguous = false;
                            break;
                        }
                    }
                    if (!isContiguous) break;
                }

                if (isContiguous) {
                    const newSel = { x: startSrcX, y: startSrcY, w: newBrush.width, h: newBrush.height };
                    setPaletteSelection(newSel);
                    addRecentStamp(newSel);
                } else {
                    // Clear palette selection to indicate custom brush
                    setPaletteSelection({ x: 0, y: 0, w: 0, h: 0 }); // Or some indicator
                }
            }

        }
    }

    // Load Image and Init
    useEffect(() => {
        if (!spritesheet) return;
        const img = new Image();
        img.src = spritesheet;
        img.onload = () => {

            setImage(img);
        };
    }, []);

    useEffect(() => {
        function handleKeyDown(e: KeyboardEvent) {
            if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;

            if (e.code === "Space") {
                e.preventDefault();
                isSpacePressed.current = true;
                document.body.style.cursor = "grab";
                return;
            }

            if (e.key.toLowerCase() === "i") {
                if (selection) {
                    sampleArea(selection);
                } else {
                    setCurrentTool("eyedropper");
                }
            }
            if (e.key.toLowerCase() === "b") setCurrentTool("brush");
            if (e.key.toLowerCase() === "e") setCurrentTool("eraser");
            if (e.key.toLowerCase() === "g" || e.key.toLowerCase() === "f") setCurrentTool("fill");
            if (e.key.toLowerCase() === "x") setIsFlipped(prev => !prev);

            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                e.preventDefault();
                setPaletteSelection(prev => {
                    if (!image) return prev;
                    let { x, y } = prev;
                    const maxW = Math.floor(image.width / TILE_WIDTH) - 1;
                    const maxH = Math.floor(image.height / TILE_HEIGHT) - 1;
                    if (e.key === "ArrowLeft") x = Math.max(0, x - 1);
                    if (e.key === "ArrowRight") x = Math.min(maxW, x + 1);
                    if (e.key === "ArrowUp") y = Math.max(0, y - 1);
                    if (e.key === "ArrowDown") y = Math.min(maxH, y + 1);

                    const newSel = { ...prev, x, y };
                    addRecentStamp(newSel);

                    // Sync custom brush explicitly here since we need access to the calculated newSel
                    // and we can't easily use the helper inside the functional update.
                    const tilesPerRow = Math.floor(image.width / TILE_WIDTH);
                    const brushData: Record<string, TileData> = {};
                    for (let dy = 0; dy < newSel.h; dy++) {
                        for (let dx = 0; dx < newSel.w; dx++) {
                            const srcX = newSel.x + dx;
                            const srcY = newSel.y + dy;
                            const tileId = srcY * tilesPerRow + srcX;
                            brushData[`${dx},${dy}`] = { tileId, flipX: false };
                        }
                    }
                    setCustomBrush({
                        width: newSel.w,
                        height: newSel.h,
                        data: brushData
                    });

                    return newSel;
                });
                setCurrentTool("brush");
            }

            if (e.key === "Delete" || e.key === "Backspace") {
                if (selection) {
                    saveCheckpoint();
                    setLayers((draft) => {
                        const activeData = draft[activeLayerIndex].data;
                        for (let x = selection.x; x < selection.x + selection.w; x++) {
                            for (let y = selection.y; y < selection.y + selection.h; y++) {
                                delete activeData[`${x},${y}`];
                            }
                        }
                    });
                }
            }

            if ((e.metaKey || e.ctrlKey) && e.key === "z") {
                e.preventDefault();
                if (e.shiftKey) {
                    performRedo();
                } else {
                    performUndo();
                }
            }

            if ((e.metaKey || e.ctrlKey) && e.key === "c") {
                if (selection) {
                    const newClipboard: Record<string, TileData> = {};
                    const activeData = layers[activeLayerIndex].data;
                    for (let x = selection.x; x < selection.x + selection.w; x++) {
                        for (let y = selection.y; y < selection.y + selection.h; y++) {
                            const key = `${x},${y}`;
                            if (activeData[key]) {
                                newClipboard[`${x - selection.x},${y - selection.y}`] = activeData[key];
                            }
                        }
                    }
                    setClipboard(newClipboard);
                    console.log("Copied", Object.keys(newClipboard).length, "tiles");
                }
            }

            if ((e.metaKey || e.ctrlKey) && e.key === "v") {
                if (clipboard) {
                    saveCheckpoint();
                    const targetX = selection ? selection.x : 0;
                    const targetY = selection ? selection.y : 0;

                    setLayers((draft) => {
                        const activeData = draft[activeLayerIndex].data;
                        let maxClipboardX = 0;
                        if (isFlipped) {
                            Object.keys(clipboard).forEach(key => {
                                const [gx] = key.split(",").map(Number);
                                if (gx > maxClipboardX) maxClipboardX = gx;
                            });
                        }
                        Object.entries(clipboard).forEach(([key, tileData]) => {
                            const [gx, gy] = key.split(",").map(Number);
                            let finalGx = gx;
                            let finalTileData = { ...tileData };
                            if (isFlipped) {
                                finalGx = maxClipboardX - gx;
                                finalTileData.flipX = !finalTileData.flipX;
                            }
                            const finalX = targetX + finalGx;
                            const finalY = targetY + gy;
                            activeData[`${finalX},${finalY}`] = finalTileData;
                        });
                    });
                }
            }
        }

        function handleKeyUp(e: KeyboardEvent) {
            if (e.code === "Space") {
                isSpacePressed.current = false;
                isPanning.current = false;
                document.body.style.cursor = "default";
            }
        }

        window.addEventListener("keydown", handleKeyDown);
        window.addEventListener("keyup", handleKeyUp);
        return () => {
            window.removeEventListener("keydown", handleKeyDown);
            window.removeEventListener("keyup", handleKeyUp);
        };
    }, [layers, selection, clipboard, activeLayerIndex, isFlipped, image]);

    // Resize Logic
    useEffect(() => {
        function handleMouseMove(e: globalThis.MouseEvent) {
            if (isResizing.current) {
                let newWidth = e.clientX;
                if (newWidth < 150) newWidth = 150;
                if (newWidth > 800) newWidth = 800;
                setPaletteWidth(newWidth);
            }
        }

        function handleMouseUp() {
            isResizing.current = false;
            document.body.style.cursor = "default";
        }

        window.addEventListener("mousemove", handleMouseMove);
        window.addEventListener("mouseup", handleMouseUp);
        return () => {
            window.removeEventListener("mousemove", handleMouseMove);
            window.removeEventListener("mouseup", handleMouseUp);
        };
    }, []);

    function paintTile(gridX: number, gridY: number, tileId: number | null, flipX?: boolean) {
        const gx = Math.floor(gridX / TILE_WIDTH);
        const gy = Math.floor(gridY / TILE_HEIGHT);
        const key = `${gx},${gy}`;

        setLayers((draft) => {
            const activeData = draft[activeLayerIndex].data;
            if (tileId === null) {
                delete activeData[key];
            } else {
                activeData[key] = { tileId, flipX: flipX !== undefined ? flipX : isFlipped };
            }
        });
    }

    function floodFill(startGridX: number, startGridY: number, fillTileId: number) {
        const startKey = `${startGridX},${startGridY}`;
        setLayers((draft) => {
            const activeData = draft[activeLayerIndex].data;
            const startTileId = activeData[startKey]?.tileId;

            if (startTileId === fillTileId) return;

            const visited = new Set<string>();
            const queue = [[startGridX, startGridY]];

            const getId = (x: number, y: number) => activeData[`${x},${y}`]?.tileId;

            while (queue.length > 0) {
                const [cx, cy] = queue.pop()!;
                const key = `${cx},${cy}`;

                if (visited.has(key)) continue;
                if (cx < 0 || cx >= mapSize.width || cy < 0 || cy >= mapSize.height) continue;

                const currentId = getId(cx, cy);
                if (currentId !== startTileId) continue;

                visited.add(key);
                activeData[key] = { tileId: fillTileId, flipX: isFlipped };

                queue.push([cx + 1, cy]);
                queue.push([cx - 1, cy]);
                queue.push([cx, cy + 1]);
                queue.push([cx, cy - 1]);
            }
        });
    }

    function handleMapInteraction(e: MouseEvent<HTMLCanvasElement>) {
        if (isPanning.current) return;

        // e.nativeEvent.offsetX is relative to the canvas
        // Account for Zoom AND Camera Offset
        const x = (e.nativeEvent.offsetX / zoomMap) - cameraOffset.x;
        const y = (e.nativeEvent.offsetY / zoomMap) - cameraOffset.y;

        const pixelWidth = mapSize.width * TILE_WIDTH;
        const pixelHeight = mapSize.height * TILE_HEIGHT;

        if (x < 0 || y < 0 || x >= pixelWidth || y >= pixelHeight) return;

        const gridX = Math.floor(x / TILE_WIDTH) * TILE_WIDTH;
        const gridY = Math.floor(y / TILE_HEIGHT) * TILE_HEIGHT;
        const gx = Math.floor(x / TILE_WIDTH);
        const gy = Math.floor(y / TILE_HEIGHT);
        const tileKey = `${gx},${gy}`;

        if (lastPaintedTiles.current.has(tileKey)) return;


        if (!image) return;
        const tilesPerRow = Math.floor(image.width / TILE_WIDTH);

        if (currentTool === "brush") {
            if (customBrush) {
                // Unified Paint Logic
                Object.entries(customBrush.data).forEach(([key, tileData]) => {
                    const [dx, dy] = key.split(",").map(Number);

                    // Mirror the brush layout if flipped
                    const finalDx = isFlipped ? (customBrush.width - 1 - dx) : dx;

                    const targetX = gridX + (finalDx * TILE_WIDTH);
                    const targetY = gridY + (dy * TILE_HEIGHT);

                    if (targetX >= pixelWidth || targetY >= pixelHeight) return;

                    // Combined Flip Logic: Source Flip XOR Global Flip
                    const combinedFlip = tileData.flipX !== isFlipped;

                    paintTile(targetX, targetY, tileData.tileId, combinedFlip);
                });
            }

            lastPaintedTiles.current.add(tileKey);
            // We assume customBrush is always set now if we are brushing.
            // If it's a "Standard" selection, it's already in history via updatePaletteSelection.
            // If it's a "Custom" sampled brush, we added it to history if applicable in sampleArea.
        } else if (currentTool === "eraser") {
            paintTile(gridX, gridY, null);
            lastPaintedTiles.current.add(tileKey);
        } else if (currentTool === "fill" && e.type === "mousedown") {
            const fillTileId = paletteSelection.y * tilesPerRow + paletteSelection.x;
            floodFill(gx, gy, fillTileId);
        } else if (currentTool === "marquee" || currentTool === "eyedropper") {
            if (e.type === "mousedown") {
                selectionStart.current = { x: gx, y: gy };
                setSelection({ x: gx, y: gy, w: 1, h: 1 });
            } else if (isMouseDown.current && selectionStart.current) {
                const start = selectionStart.current;
                const minX = Math.min(start.x, gx);
                const minY = Math.min(start.y, gy);
                const w = Math.abs(start.x - gx) + 1;
                const h = Math.abs(start.y - gy) + 1;
                setSelection({ x: minX, y: minY, w, h });
            }
        }
    }

    function handleMapMouseDown(e: MouseEvent<HTMLCanvasElement>) {
        if (isSpacePressed.current) {
            isPanning.current = true;
            document.body.style.cursor = "grabbing";
            return;
        }

        // Eyedropper Logic
        // Alt-click to quick pick single tile (Legacy/Power User)
        if (e.altKey) {
            if (!image) return;
            const x = (e.nativeEvent.offsetX / zoomMap) - cameraOffset.x;
            const y = (e.nativeEvent.offsetY / zoomMap) - cameraOffset.y;
            const gx = Math.floor(x / TILE_WIDTH);
            const gy = Math.floor(y / TILE_HEIGHT);

            sampleArea({ x: gx, y: gy, w: 1, h: 1 });
            return;
        }

        if (currentTool !== "marquee" && currentTool !== "eyedropper") {
            saveCheckpoint();
        }
        isMouseDown.current = true;
        lastPaintedTiles.current.clear();
        handleMapInteraction(e);
    }

    function handleMapMouseMove(e: MouseEvent<HTMLCanvasElement>) {
        if (isPanning.current) {
            setCameraOffset(prev => ({
                x: prev.x + e.movementX / zoomMap,
                y: prev.y + e.movementY / zoomMap
            }));
            return;
        }

        if (isMouseDown.current) {
            handleMapInteraction(e);
        }
    }

    function handleMapMouseUp() {
        if (isPanning.current) {
            isPanning.current = false;
            document.body.style.cursor = isSpacePressed.current ? "grab" : "default";
            return;
        }

        isMouseDown.current = false;
        lastPaintedTiles.current.clear();

        if (currentTool === "eyedropper" && selection) {
            sampleArea(selection);
        }
    }

    function handleUploadImage(e: React.ChangeEvent<HTMLInputElement>) {
        const file = e.target.files?.[0];
        if (!file) return;

        const img = new Image();
        img.onload = () => {
            setImage(img);
        };
        img.src = URL.createObjectURL(file);
    }

    function handleSaveMap() {
        const jsonString = JSON.stringify(layers, null, 2);
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "map_data.json";
        a.click();
        URL.revokeObjectURL(url);
    }

    function handleLoadMap(e: React.ChangeEvent<HTMLInputElement>) {
        const file = e.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const json = JSON.parse(ev.target?.result as string);
                if (Array.isArray(json)) {
                    setLayers(json);
                } else if (typeof json === "object" && json !== null) {
                    // Legacy
                    setLayers(draft => {
                        draft[0].data = json;
                    });
                } else {
                    alert("Invalid JSON format");
                }
            } catch (error) {
                alert("Failed to parse JSON");
            }
        };
        reader.readAsText(file);
    }

    function handleExportPng() {
        if (!image) return;

        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = mapSize.width * TILE_WIDTH;
        tempCanvas.height = mapSize.height * TILE_HEIGHT;
        const ctx = tempCanvas.getContext("2d");
        if (!ctx) return;

        layers.forEach(layer => {
            if (!layer.visible) return;
            ctx.globalAlpha = layer.opacity;

            Object.entries(layer.data).forEach(([key, tileData]) => {
                const [gx, gy] = key.split(",").map(Number);
                const drawX = gx * TILE_WIDTH;
                const drawY = gy * TILE_HEIGHT;

                const tilesPerRow = Math.floor(image.width / TILE_WIDTH);
                const srcX = (tileData.tileId % tilesPerRow) * TILE_WIDTH;
                const srcY = Math.floor(tileData.tileId / tilesPerRow) * TILE_HEIGHT;

                ctx.save();
                if (tileData.flipX) {
                    ctx.translate(drawX + TILE_WIDTH, drawY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, 0, 0, TILE_WIDTH, TILE_HEIGHT);
                } else {
                    ctx.drawImage(image, srcX, srcY, TILE_WIDTH, TILE_HEIGHT, drawX, drawY, TILE_WIDTH, TILE_HEIGHT);
                }
                ctx.restore();
            });
        });

        const url = tempCanvas.toDataURL("image/png");
        const a = document.createElement("a");
        a.href = url;
        a.download = "map_image.png";
        a.click();
    }

    return (
        <div className="h-screen flex flex-col p-4 box-border">
            <h1 className="text-2xl font-bold mb-4">Map Editor</h1>

            <Toolbar
                mapSize={mapSize}
                setMapSize={setMapSize}
                currentTool={currentTool}
                setCurrentTool={setCurrentTool}
                onSave={handleSaveMap}
                onLoad={handleLoadMap}
                onExport={handleExportPng}
                onUploadImage={handleUploadImage}
            />

            <RecentTiles
                recentStamps={recentStamps}
                onSelect={(stamp) => {
                    updatePaletteSelection(stamp);
                    setCurrentTool("brush");
                    addRecentStamp(stamp);
                }}
                image={image}
                activeStamp={paletteSelection}
            />

            <div className="flex gap-4 items-start flex-1 overflow-hidden">
                <div
                    className="flex-none flex flex-col h-full"
                    style={{ width: paletteWidth }}
                >
                    <Palette
                        image={image}
                        selection={paletteSelection}
                        setSelection={(val) => {
                            if (typeof val === 'function') {
                                setPaletteSelection(prev => {
                                    const next = val(prev);
                                    updatePaletteSelection(next); // Recalculate brush
                                    return next;
                                });
                            } else {
                                updatePaletteSelection(val);
                            }
                        }}
                        zoom={zoomPalette}
                        setZoom={setZoomPalette}
                        isFlipped={isFlipped}
                        onToolChange={() => {
                            setCurrentTool("brush");
                            // Note: Palette internal clicks will need to call setSelection
                            // We need to make sure Palette calls the passed setSelection prop.
                            // If Palette allows choosing new rect, it works.
                        }}
                    />
                </div>

                <div
                    className="w-1 cursor-col-resize h-full hover:bg-blue-400 bg-gray-200 flex-none transition-colors"
                    onMouseDown={() => {
                        isResizing.current = true;
                        document.body.style.cursor = "col-resize";
                    }}
                />

                <div className="flex-1 h-full min-w-0 flex flex-col">
                    <h3 className="font-bold mb-2">Map</h3>
                    <MapCanvas
                        layers={layers}
                        mapSize={mapSize}

                        zoom={zoomMap}
                        setZoom={setZoomMap}
                        cameraOffset={cameraOffset}
                        selection={selection}
                        image={image}
                        currentTool={currentTool}
                        paletteSelection={paletteSelection}
                        isFlipped={isFlipped}
                        customBrush={customBrush}
                        onMouseDown={handleMapMouseDown}
                        onMouseMove={handleMapMouseMove}
                        onMouseUp={handleMapMouseUp}
                        onMouseLeave={handleMapMouseUp}
                    />

                    <LayerPanel
                        layers={layers}
                        activeLayerIndex={activeLayerIndex}
                        setActiveLayerIndex={setActiveLayerIndex}
                        onToggleVisibility={(index) => {
                            setLayers(draft => {
                                draft[index].visible = !draft[index].visible;
                            });
                        }}
                        onOpacityChange={(index, opacity) => {
                            setLayers(draft => {
                                draft[index].opacity = opacity;
                            });
                        }}
                        onMoveLayer={(index, direction) => {
                            setLayers(draft => {
                                const targetIndex = direction === 'up' ? index + 1 : index - 1;
                                if (targetIndex < 0 || targetIndex >= draft.length) return;

                                const temp = draft[index];
                                draft[index] = draft[targetIndex];
                                draft[targetIndex] = temp;

                                // Update active index if we moved the active layer or swapped with it
                                if (activeLayerIndex === index) {
                                    setActiveLayerIndex(targetIndex);
                                } else if (activeLayerIndex === targetIndex) {
                                    setActiveLayerIndex(index);
                                }
                            });
                        }}
                        onAddLayer={() => {
                            const name = prompt("Enter layer name:", "New Layer");
                            if (name !== null) {
                                addLayer(name || "Layer");
                                setActiveLayerIndex(layers.length);
                            }
                        }}
                        onRemoveLayer={(index) => {
                            removeLayer(index);
                            // If we deleted the active layer, or a layer below it, adjust
                            if (activeLayerIndex >= index) {
                                setActiveLayerIndex(Math.max(0, activeLayerIndex - 1));
                            }
                        }}
                        onRenameLayer={renameLayer}
                    />
                </div>
            </div>
        </div>
    );
}

```

